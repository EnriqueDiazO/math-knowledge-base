"""
Auto-generated by scripts/split_cuaderno_page.py
Source: editor/editor_streamlit.py
Generated at: 2026-01-21T01:25:18.076642Z
"""

from __future__ import annotations

import os
import re
from collections import Counter
from datetime import date
from datetime import datetime
from datetime import timedelta
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from bson import ObjectId
from pdf_export import generar_tex_nota_latex, generar_pdf_nota_latex
import streamlit as st
import pandas as pd
from streamlit_ace import st_ace

def _find_one_by_id(coll, id_value):
    """Find a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    # Normalize to string for parsing
    s = str(id_value)
    # First try ObjectId
    try:
        oid = ObjectId(s)
        doc = coll.find_one({"_id": oid})
        if doc is not None:
            return doc
    except Exception:
        pass
    # Fallback: string _id
    try:
        return coll.find_one({"_id": s})
    except Exception:
        return None


def _update_one_by_id(coll, id_value, update_doc):
    """Update a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    s = str(id_value)
    try:
        oid = ObjectId(s)
        res = coll.update_one({"_id": oid}, update_doc)
        if getattr(res, "matched_count", 0) > 0:
            return res
    except Exception:
        pass
    try:
        return coll.update_one({"_id": s}, update_doc)
    except Exception:
        return None




def _worklog_label(doc: Dict[str, Any]) -> str:
    """Etiqueta compacta para seleccionar entradas de Worklog."""
    d = doc.get("date") or ""
    block = doc.get("block") or "‚Äî"
    proj = doc.get("project") or "‚Äî"
    task = doc.get("task") or "(sin task)"
    status = doc.get("status") or "‚Äî"
    return f"{d} [{block}] ({status}) {proj} ‚Äî {task}"


def _safe_date_from_str(s: str) -> date:
    """Parse YYYY-MM-DD safely; fallback to today."""
    try:
        return datetime.strptime((s or "").strip(), "%Y-%m-%d").date()
    except Exception:
        return date.today()


def _iso_from_date_str(date_str: str) -> Dict[str, int]:
    """Return ISO year/week from YYYY-MM-DD; fallback to today's ISO values."""
    try:
        dt = datetime.strptime(date_str, "%Y-%m-%d")
        iso = dt.isocalendar()
        return {
            "iso_year": int(getattr(iso, "year", iso[0])),
            "iso_week": int(getattr(iso, "week", iso[1])),
        }
    except Exception:
        iso = date.today().isocalendar()
        return {"iso_year": int(iso.year), "iso_week": int(iso.week)}


def _parse_tags_csv(s: str) -> List[str]:
    """Parse comma-separated tags into a clean list."""
    if not s:
        return []
    parts = [p.strip() for p in s.split(",")]
    return [p for p in parts if p]


def _note_label(doc: Dict[str, Any]) -> str:
    d = doc.get("date") or ""
    title = doc.get("title") or "(sin t√≠tulo)"
    proj = doc.get("project") or "‚Äî"
    ctx = doc.get("context") or "‚Äî"
    return f"{d} ‚Äî {title}  ¬∑  {proj} / {ctx}"


def _get_editor_keys(prefix: str) -> Dict[str, str]:
    return {
        "text": f"{prefix}_latex_text",
        "rev": f"{prefix}_latex_editor_rev",
        "insert": f"{prefix}_latex_insert",
        "do_insert": f"{prefix}_insert_latex",
        "loaded_id": f"{prefix}_loaded_id",
    }


def _ensure_editor_state(prefix: str, initial_text: str = "") -> None:
    keys = _get_editor_keys(prefix)
    if keys["text"] not in st.session_state:
        st.session_state[keys["text"]] = initial_text or ""
    if keys["rev"] not in st.session_state:
        st.session_state[keys["rev"]] = 0
    if keys["insert"] not in st.session_state:
        st.session_state[keys["insert"]] = ""
    if keys["do_insert"] not in st.session_state:
        st.session_state[keys["do_insert"]] = False
    if keys["loaded_id"] not in st.session_state:
        st.session_state[keys["loaded_id"]] = ""


def _queue_insert(prefix: str, snippet: str) -> None:
    keys = _get_editor_keys(prefix)
    st.session_state[keys["insert"]] = snippet
    st.session_state[keys["do_insert"]] = True


def _handle_pending_insert(prefix: str) -> None:
    keys = _get_editor_keys(prefix)
    if st.session_state.get(keys["do_insert"]) and st.session_state.get(keys["insert"]):
        current_text = st.session_state.get(keys["text"], "") or ""
        to_insert = st.session_state[keys["insert"]]

        if current_text and not current_text.endswith("\n"):
            current_text += "\n"

        st.session_state[keys["text"]] = current_text + to_insert + "\n"
        st.session_state[keys["do_insert"]] = False
        st.session_state[keys["insert"]] = ""
        st.session_state[keys["rev"]] = st.session_state.get(keys["rev"], 0) + 1
        st.rerun()


def _render_latex_toolbar(prefix: str) -> None:
    """Toolbar: same spirit as 'A√±adir Concepto' + semantic diary blocks."""
    st.write("**üîß Herramientas LaTeX:**")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        if st.button("üìù Definici√≥n", key=f"{prefix}_btn_def"):
            _queue_insert(prefix, "\\begin{definition}\n% ...\n\\end{definition}\n")
        if st.button("üìã Teorema", key=f"{prefix}_btn_theorem"):
            _queue_insert(prefix, "\\begin{theorem}{% ...}\n% ...\n\\end{theorem}\n")
        if st.button("üìå Lema", key=f"{prefix}_btn_lemma"):
            _queue_insert(prefix, "\\begin{lemma}\n% ...\n\\end{lemma}\n")
        if st.button("üìå Proposici√≥n", key=f"{prefix}_btn_prop"):
            _queue_insert(prefix, "\\begin{proposition}\n% ...\n\\end{proposition}\n")
        if st.button("üìã Corolario", key=f"{prefix}_btn_cor"):
            _queue_insert(prefix, "\\begin{corollary}\n% ...\n\\end{corollary}\n")
        if st.button("üìñ Prueba", key=f"{prefix}_btn_proof"):
            _queue_insert(prefix, "\\begin{proof}\n% ...\n\\end{proof}\n")

    with col2:
        if st.button("üß™ Ejemplo", key=f"{prefix}_btn_ex"):
            _queue_insert(prefix, "\\begin{example}\n% ...\n\\end{example}\n")
        if st.button("üóíÔ∏è Nota / Remark", key=f"{prefix}_btn_remark"):
            _queue_insert(prefix, "\\begin{remark}\n% ...\n\\end{remark}\n")
        if st.button("üî¢ Ecuaci√≥n", key=f"{prefix}_btn_eq"):
            _queue_insert(prefix, "\\begin{equation}\n% ...\n\\end{equation}\n")
        if st.button("üî¢ Align", key=f"{prefix}_btn_align"):
            _queue_insert(prefix, "\\begin{align}\n% ...\n\\end{align}\n")
        if st.button("üî¢ Matrix", key=f"{prefix}_btn_matrix"):
            _queue_insert(prefix, "\\begin{pmatrix}\na & b \\\\\nc & d\n\\end{pmatrix}\n")
        if st.button("üî¢ Cases", key=f"{prefix}_btn_cases"):
            _queue_insert(prefix, "\\begin{cases}\n% ...\n\\end{cases}\n")

    with col3:
        if st.button("‚Ä¢ Itemize", key=f"{prefix}_btn_itemize"):
            _queue_insert(prefix, "\\begin{itemize}\n  \\item ...\n\\end{itemize}\n")
        if st.button("1) Enumerate", key=f"{prefix}_btn_enum"):
            _queue_insert(prefix, "\\begin{enumerate}\n  \\item ...\n\\end{enumerate}\n")
        if st.button("‚â° Description", key=f"{prefix}_btn_desc"):
            _queue_insert(prefix, "\\begin{description}\n  \\item[\√çtem] ...\n\\end{description}\n")
        if st.button("üíª C√≥digo (lstlisting)", key=f"{prefix}_btn_code"):
            _queue_insert(prefix, "\\begin{lstlisting}\n# ...\n\\end{lstlisting}\n")
        if st.button("üìÅ DirTree", key=f"{prefix}_btn_dirtree"):
            _queue_insert(prefix, "\\begin{dirtree}\n.1 /ruta.\n.2 archivo.txt.\n\\end{dirtree}\n")

    with col4:
        # S√≠mbolos (m√≠nimo viable)
        sym_cols = st.columns(2)
        with sym_cols[0]:
            if st.button("‚àë", key=f"{prefix}_sym_sum"):
                _queue_insert(prefix, "\\sum_{i=1}^{n}")
            if st.button("‚à´", key=f"{prefix}_sym_int"):
                _queue_insert(prefix, "\\int_{a}^{b}")
            if st.button("‚àà", key=f"{prefix}_sym_in"):
                _queue_insert(prefix, "\\in")
            if st.button("‚àÄ", key=f"{prefix}_sym_forall"):
                _queue_insert(prefix, "\\forall")
            if st.button("‚Ñù", key=f"{prefix}_sym_R"):
                _queue_insert(prefix, "\\mathbb{R}")
        with sym_cols[1]:
            if st.button("‚àÉ", key=f"{prefix}_sym_exists"):
                _queue_insert(prefix, "\\exists")
            if st.button("‚Üí", key=f"{prefix}_sym_to"):
                _queue_insert(prefix, "\\rightarrow")
            if st.button("‚àû", key=f"{prefix}_sym_inf"):
                _queue_insert(prefix, "\\infty")
            if st.button("Œµ", key=f"{prefix}_sym_eps"):
                _queue_insert(prefix, "\\varepsilon")
            if st.button("Œ¥", key=f"{prefix}_sym_delta"):
                _queue_insert(prefix, "\\delta")

    st.write("**üß© Bloques sem√°nticos del cuaderno:**")
    b1, b2, b3, b4, b5 = st.columns(5)
    semantic = [
        ("context", b1),
        ("reading", b1),
        ("exploration", b2),
        ("hypothesis", b2),
        ("connections", b3),
        ("reflection", b3),
        ("decision", b4),
        ("openquestions", b4),
        ("technical", b5),
        ("nextsteps", b5),
    ]
    for name, col in semantic:
        with col:
            if st.button(name, key=f"{prefix}_sem_{name}"):
                _queue_insert(prefix, f"\\begin{{{name}}}\n...\n\\end{{{name}}}\n")


def _render_latex_ace_editor(prefix: str, initial_text: str, height: int = 320) -> str:
    """Ace editor with deterministic insertion mechanism (stable on reruns)."""
    _ensure_editor_state(prefix, initial_text=initial_text)
    _handle_pending_insert(prefix)

    keys = _get_editor_keys(prefix)
    value = st_ace(
        value=st.session_state[keys["text"]],
        language="latex",
        theme="monokai",
        font_size=16,
        tab_size=2,
        height=height,
        wrap=True,
        show_gutter=True,
        auto_update=True,
        key=f"{prefix}_latex_editor_{st.session_state[keys['rev']]}",
    )
    st.session_state[keys["text"]] = value or ""
    return st.session_state[keys["text"]]
def render_cuaderno(db, _cuaderno_is_installed: Callable[[], bool]) -> None:
    """
    Renderiza la p√°gina üß™ Cuaderno (Experimental).

    Args:
        db: handle de MongoDB (pymongo database)
        _cuaderno_is_installed: funci√≥n que valida si el modo cuaderno est√° instalado
    """
    st.title("üß™ Cuaderno (Experimental)")

    if db is None:
        st.error("‚ùå No database connection. Please select a database in the sidebar.")
        st.stop()

    if not _cuaderno_is_installed(db):
        st.warning(
        "El modo cuaderno no est√° instalado en esta base de datos. "
        "Ejecuta: `make cuaderno-install`"
    )
    else:
        mongo_db = getattr(db, "db", None)
        if mongo_db is None:
            st.error("‚ùå No se pudo acceder al objeto pymongo database (db.db).")
            st.stop()

    c_worklog = mongo_db["worklog_entries"].count_documents({})
    c_backlog = mongo_db["backlog_items"].count_documents({})
    c_weekly = mongo_db["weekly_reviews"].count_documents({})
    c_deliv = mongo_db["deliverables"].count_documents({})
    c_notes = mongo_db["latex_notes"].count_documents({})

    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("Worklog", c_worklog)
    col2.metric("Backlog", c_backlog)
    col3.metric("Weekly", c_weekly)
    col4.metric("Deliverables", c_deliv)
    col5.metric("Diario", c_notes)

    st.info(
        "Este m√≥dulo es experimental. En los siguientes MVP mejoraremos los sectores: "
        "Worklog ‚Üí Backlog ‚Üí Weekly Review ‚Üí Deliverables ‚Üí Kanban."
    )
    with st.expander("Instalaci√≥n / Estado", expanded=False):
        st.code("make cuaderno-install\nmake cuaderno-status", language="bash")

    tabs = st.tabs(["Worklog", "Backlog", "Weekly Review", "Deliverables", "Kanban", "Diario"])

    with tabs[0]:
        st.subheader("üïí Worklog")

        with st.form("worklog_form", clear_on_submit=False):
            col_a, col_b = st.columns(2)

            with col_a:
                w_date = st.date_input("Date", value=datetime.today())
                w_block = st.selectbox("Block", ["AM", "PM", "Noche"])
                w_hours = st.number_input("Hours", min_value=0.0, value=0.0, step=0.25)
                w_status = st.selectbox(
                    "Status",
                    ["Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                )

            with col_b:
                w_project = st.text_input("Project")
                w_module = st.text_input("Module (optional)")
                w_task = st.text_input("Task")
                w_next_step = st.text_input("Next step (optional)")

            w_desc = st.text_area("Descripci√≥n / Evidencia (optional)")
            w_evidence_url = st.text_input("Evidence URL / path (optional)")
            w_tags_csv = st.text_input("Tags (comma-separated)")

            submitted = st.form_submit_button("Add Worklog Entry")

        if submitted:
            if not w_project.strip() or not w_task.strip():
                st.error("Project y Task son obligatorios.")
            else:
                date_str = w_date.strftime("%Y-%m-%d")
                iso = datetime.strptime(date_str, "%Y-%m-%d").isocalendar()
                iso_year = int(getattr(iso, "year", iso[0]))
                iso_week = int(getattr(iso, "week", iso[1]))

                tags = [t.strip() for t in w_tags_csv.split(",") if t.strip()]
                now = datetime.utcnow()

                doc = {
                    "date": date_str,
                    "block": w_block,
                    "start_time": None,
                    "end_time": None,
                    "hours": float(w_hours),
                    "project": w_project.strip(),
                    "module": w_module.strip() or None,
                    "task": w_task.strip(),
                    "description_evidence": w_desc.strip() or None,
                    "status": w_status,
                    "deliverable_id": None,
                    "evidence_url": w_evidence_url.strip() or None,
                    "next_step": w_next_step.strip() or None,
                    "tags": tags,
                    "iso_year": iso_year,
                    "iso_week": iso_week,
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    mongo_db["worklog_entries"].insert_one(doc)
                    st.success("‚úÖ Worklog entry guardada.")
                except Exception as e:
                    st.error(f"‚ùå Error guardando worklog: {e}")

        st.markdown("### Recientes (√∫ltimas 20 entradas)")
        try:
            rows = list(
                mongo_db["worklog_entries"]
                .find({})
                .sort([("date", -1), ("created_at", -1)])
                .limit(20)
            )
            if not rows:
                st.info("A√∫n no hay entradas en worklog.")
            else:
                # Para inspecci√≥n/selecci√≥n: convierte _id a string (sin perder el id real en Mongo).
                df_rows = []
                for r in rows:
                    rr = dict(r)
                    rr["_id"] = str(rr.get("_id"))
                    df_rows.append(rr)
                df = pd.DataFrame(df_rows)
                st.dataframe(df, width='stretch')
        except Exception as e:
            st.error(f"‚ùå Error cargando worklog: {e}")

        st.divider()
        st.markdown("### ‚¨áÔ∏è Exportar Worklog a CSV (MVP-4)")
        st.caption("Selecciona entradas y desc√°rgalas como CSV. Por defecto se muestran las entradas recientes; opcionalmente puedes filtrar.")

        export_mode = st.selectbox(
            "Modo de exportaci√≥n",
            options=["Seleccionar de Recientes", "Consulta con filtros"],
            index=0,
            key="worklog_export_mode",
        )

        export_df = pd.DataFrame()

        if export_mode == "Seleccionar de Recientes":
            # Reusar la tabla de 'Recientes' si est√° disponible en este scope.
            if "df" in locals() and isinstance(df, pd.DataFrame) and not df.empty:
                export_df = df.copy()
            else:
                export_df = pd.DataFrame()
        else:
            with st.expander("Filtros", expanded=False):
                c1, c2, c3 = st.columns(3)
                with c1:
                    start_d = st.date_input("Desde", value=(date.today() - timedelta(days=7)), key="worklog_export_start")
                with c2:
                    end_d = st.date_input("Hasta", value=date.today(), key="worklog_export_end")
                with c3:
                    limit_n = st.number_input("L√≠mite", min_value=10, max_value=5000, value=500, step=50, key="worklog_export_limit")

                c4, c5, c6 = st.columns(3)
                with c4:
                    try:
                        proj_opts = sorted([p for p in mongo_db["worklog_entries"].distinct("project") if isinstance(p, str)])
                    except Exception:
                        proj_opts = []
                    flt_project = st.selectbox("Project", options=["(all)"] + proj_opts, index=0, key="worklog_export_project")
                with c5:
                    flt_status = st.selectbox(
                        "Status",
                        options=["(all)", "Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                        index=0,
                        key="worklog_export_status",
                    )
                with c6:
                    text_q = st.text_input("Contiene (task/description)", value="", key="worklog_export_text")

            q = {
                "date": {"$gte": start_d.strftime("%Y-%m-%d"), "$lte": end_d.strftime("%Y-%m-%d")}
            }
            if flt_project != "(all)":
                q["project"] = flt_project
            if flt_status != "(all)":
                q["status"] = flt_status
            if (text_q or "").strip():
                rx = {"$regex": re.escape(text_q.strip()), "$options": "i"}
                q["$or"] = [{"task": rx}, {"description_evidence": rx}]

            try:
                docs = list(
                    mongo_db["worklog_entries"]
                    .find(q)
                    .sort([("date", -1), ("created_at", -1)])
                    .limit(int(limit_n))
                )
                norm = []
                for d in docs:
                    dd = dict(d)
                    dd["_id"] = str(dd.get("_id"))
                    norm.append(dd)
                export_df = pd.DataFrame(norm)
            except Exception as e:
                st.error(f"‚ùå Error preparando exportaci√≥n: {e}")
                export_df = pd.DataFrame()

        if export_df.empty:
            st.info("No hay filas para exportar con los criterios actuales.")
        else:
            # Normaliza _id para CSV y selecci√≥n
            if "_id" in export_df.columns:
                export_df["_id"] = export_df["_id"].astype(str)

            if "select" not in export_df.columns:
                export_df.insert(0, "select", False)

            edited_df = st.data_editor(
                export_df,
                use_container_width=True,
                num_rows="fixed",
                key="worklog_export_editor",
            )

            selected_df = edited_df[edited_df["select"] == True].drop(columns=["select"], errors="ignore")

            cdl1, cdl2 = st.columns([2, 1])
            with cdl1:
                st.caption(f"Seleccionadas: {len(selected_df)} / {len(edited_df)}")
            with cdl2:
                if len(selected_df) > 0:
                    csv_bytes = selected_df.to_csv(index=False).encode("utf-8")
                    fname = f"worklog_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
                    st.download_button(
                        "Descargar CSV",
                        data=csv_bytes,
                        file_name=fname,
                        mime="text/csv",
                        key="worklog_export_download",
                    )
                else:
                    st.button("Descargar CSV", disabled=True, key="worklog_export_download_disabled")

        st.divider()
        st.markdown("### ‚úèÔ∏è Editar entrada (MVP-1)")

        try:
            edit_rows = list(
                mongo_db["worklog_entries"]
                .find({})
                .sort([("date", -1), ("created_at", -1)])
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando entradas para edici√≥n: {e}")
            edit_rows = []

        if not edit_rows:
            st.info("No hay entradas suficientes para editar.")
        else:
            edit_labels: List[str] = []
            edit_map: Dict[str, str] = {}
            for d in edit_rows:
                _id = str(d.get("_id"))
                lab = _worklog_label(d)
                edit_labels.append(lab)
                edit_map[lab] = _id

            selected_label = st.selectbox(
                "Selecciona una entrada para editar",
                options=edit_labels,
                index=0,
                key="worklog_edit_select",
            )
            wid = edit_map.get(selected_label)
            wdoc = _find_one_by_id(mongo_db["worklog_entries"], wid) if wid else None

            if not wdoc:
                st.warning("No se pudo cargar la entrada seleccionada.")
            else:
                loaded_id = st.session_state.get("worklog_edit_loaded_id")
                current_id = str(wdoc.get("_id"))
                if loaded_id != current_id:
                    st.session_state["worklog_edit_loaded_id"] = current_id
                    st.session_state["worklog_edit_date"] = _safe_date_from_str(wdoc.get("date") or "")
                    st.session_state["worklog_edit_project"] = wdoc.get("project") or ""
                    st.session_state["worklog_edit_module"] = wdoc.get("module") or ""
                    st.session_state["worklog_edit_task"] = wdoc.get("task") or ""
                    st.session_state["worklog_edit_desc"] = wdoc.get("description_evidence") or ""
                    st.session_state["worklog_edit_status"] = wdoc.get("status") or "Planificado"

                e1, e2 = st.columns(2)
                with e1:
                    ew_date = st.date_input("Date", key="worklog_edit_date")
                    ew_status = st.selectbox(
                        "Status",
                        ["Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                        key="worklog_edit_status",
                    )
                with e2:
                    ew_project = st.text_input("Project", key="worklog_edit_project")
                    ew_module = st.text_input("Module (optional)", key="worklog_edit_module")
                    ew_task = st.text_input("Task", key="worklog_edit_task")

                ew_desc = st.text_area("Descripci√≥n / Evidencia (optional)", key="worklog_edit_desc")

                if st.button("Guardar cambios", key="worklog_edit_save"):
                    if not (ew_project or "").strip() or not (ew_task or "").strip():
                        st.error("Project y Task son obligatorios.")
                    else:
                        date_str = ew_date.strftime("%Y-%m-%d")
                        iso_vals = _iso_from_date_str(date_str)
                        now = datetime.utcnow()

                        upd = {
                            "date": date_str,
                            "project": (ew_project or "").strip(),
                            "module": (ew_module or "").strip() or None,
                            "task": (ew_task or "").strip(),
                            "description_evidence": (ew_desc or "").strip() or None,
                            "status": ew_status,
                            "iso_year": int(iso_vals["iso_year"]),
                            "iso_week": int(iso_vals["iso_week"]),
                            "updated_at": now,
                        }

                        res = _update_one_by_id(
                            mongo_db["worklog_entries"],
                            wid,
                            {"$set": upd},
                        )
                        if res is not None and getattr(res, "matched_count", 0) > 0:
                            st.success("‚úÖ Worklog entry actualizada.")
                            st.rerun()
                        else:
                            st.error("‚ùå No se pudo actualizar la entrada (id no encontrado).")


        st.divider()
        st.markdown("### ‚ûï Crear entrada desde Backlog (MVP-2)")
        st.caption("Integraci√≥n unidireccional: Backlog ‚Üí Worklog. No se modifica el Backlog.")

        try:
            backlog_candidates = list(
                mongo_db["backlog_items"]
                .find({"status": {"$in": ["Todo", "Doing", "Blocked"]}})
                .sort([("updated_at", -1)])
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog: {e}")
            backlog_candidates = []

        if not backlog_candidates:
            st.info("No hay backlog items pendientes/activos (Todo/Doing/Blocked).")
        else:
            # Selector simple (reutiliza patr√≥n de selecci√≥n del m√≥dulo Backlog)
            options = []
            bmap: Dict[str, Dict[str, Any]] = {}
            for it in backlog_candidates:
                bid = str(it.get("_id"))
                label = f"[{it.get('status','')}] {it.get('project','')} ‚Äî {it.get('task','')}"
                options.append(label)
                bmap[label] = it

            sel = st.selectbox("Selecciona una actividad del Backlog", options=options, key="wfb_select")
            bdoc = bmap.get(sel)

            if bdoc is None:
                st.warning("No se pudo cargar el backlog item seleccionado.")
            else:
                bid = str(bdoc.get("_id"))
                if st.session_state.get("wfb_loaded_id") != bid:
                    st.session_state["wfb_loaded_id"] = bid
                    st.session_state["wfb_date"] = datetime.today()
                    st.session_state["wfb_block"] = "AM"
                    st.session_state["wfb_hours"] = 0.0
                    st.session_state["wfb_status"] = "En progreso"
                    st.session_state["wfb_project"] = bdoc.get("project") or ""
                    st.session_state["wfb_module"] = bdoc.get("module") or ""
                    st.session_state["wfb_task"] = bdoc.get("task") or ""
                    st.session_state["wfb_desc"] = bdoc.get("description") or ""
                    st.session_state["wfb_next_step"] = ""
                    st.session_state["wfb_evidence_url"] = ""
                    st.session_state["wfb_tags"] = ", ".join(bdoc.get("tags") or [])

                with st.form("worklog_from_backlog_form", clear_on_submit=False):
                    c1, c2 = st.columns(2)
                    with c1:
                        wfb_date = st.date_input("Date", key="wfb_date")
                        wfb_block = st.selectbox("Block", ["AM", "PM", "Noche"], key="wfb_block")
                        wfb_hours = st.number_input("Hours", min_value=0.0, step=0.25, key="wfb_hours")
                        wfb_status = st.selectbox(
                            "Status",
                            ["Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                            key="wfb_status",
                        )
                    with c2:
                        wfb_project = st.text_input("Project", key="wfb_project")
                        wfb_module = st.text_input("Module (optional)", key="wfb_module")
                        wfb_task = st.text_input("Task", key="wfb_task")
                        wfb_next_step = st.text_input("Next step (optional)", key="wfb_next_step")

                    wfb_desc = st.text_area("Descripci√≥n / Evidencia (optional)", key="wfb_desc")
                    wfb_evidence_url = st.text_input("Evidence URL / path (optional)", key="wfb_evidence_url")
                    wfb_tags_csv = st.text_input("Tags (comma-separated)", key="wfb_tags")

                    submit = st.form_submit_button("Crear Worklog Entry desde Backlog")

                if submit:
                    if not (wfb_project or "").strip() or not (wfb_task or "").strip():
                        st.error("Project y Task son obligatorios.")
                    else:
                        date_str = wfb_date.strftime("%Y-%m-%d")
                        iso_vals = _iso_from_date_str(date_str)
                        now = datetime.utcnow()

                        doc = {
                            "date": date_str,
                            "block": wfb_block,
                            "start_time": None,
                            "end_time": None,
                            "hours": float(wfb_hours),
                            "project": (wfb_project or "").strip(),
                            "module": (wfb_module or "").strip() or None,
                            "task": (wfb_task or "").strip(),
                            "description_evidence": (wfb_desc or "").strip() or None,
                            "status": wfb_status,
                            "deliverable_id": None,
                            "evidence_url": (wfb_evidence_url or "").strip() or None,
                            "next_step": (wfb_next_step or "").strip() or None,
                            "tags": [t.strip() for t in (wfb_tags_csv or "").split(",") if t.strip()],
                            "iso_year": int(iso_vals["iso_year"]),
                            "iso_week": int(iso_vals["iso_week"]),
                            "created_at": now,
                            "updated_at": now,
                            # referencia blanda al origen (no genera dependencia fuerte)
                            "source_backlog_id": bid,
                        }

                        try:
                            mongo_db["worklog_entries"].insert_one(doc)
                            st.success("‚úÖ Worklog entry creada desde Backlog.")
                            st.rerun()
                        except Exception as e:
                            st.error(f"‚ùå Error guardando worklog desde backlog: {e}")


        st.divider()
        st.markdown("### üóëÔ∏è Borrar entrada (MVP-3)")

        try:
            del_rows = list(
                mongo_db["worklog_entries"]
                .find({})
                .sort([("date", -1), ("created_at", -1)])
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando entradas para borrado: {e}")
            del_rows = []

        if not del_rows:
            st.info("No hay entradas suficientes para borrar.")
        else:
            del_labels: List[str] = []
            del_map: Dict[str, str] = {}
            for d in del_rows:
                _id = str(d.get("_id"))
                lab = _worklog_label(d)
                del_labels.append(lab)
                del_map[lab] = _id

            del_selected = st.selectbox(
                "Selecciona una entrada para borrar",
                options=del_labels,
                index=0,
                key="worklog_delete_select",
            )
            del_id = del_map.get(del_selected)
            del_doc = _find_one_by_id(mongo_db["worklog_entries"], del_id) if del_id else None

            if not del_doc:
                st.warning("No se pudo cargar la entrada seleccionada.")
            else:
                st.write(f"**Fecha:** {del_doc.get('date') or ''}  ¬∑  **Block:** {del_doc.get('block') or '‚Äî'}")
                st.write(f"**Proyecto:** {del_doc.get('project') or '‚Äî'}")
                st.write(f"**Task:** {del_doc.get('task') or '(sin task)'}")

                preview = (del_doc.get("description_evidence") or "")[:220]
                if preview:
                    st.code(preview, language="text")

                confirm = st.checkbox("Estoy seguro", key="worklog_delete_confirm")
                typed = st.text_input("Escribe BORRAR para confirmar", value="", key="worklog_delete_typed")

                if st.button("Borrar definitivamente", key="worklog_delete_btn"):
                    if not confirm or typed.strip().upper() != "BORRAR":
                        st.error("Confirmaci√≥n incompleta. Marca el checkbox y escribe BORRAR.")
                    else:
                        try:
                            s = str(del_id)
                            deleted = None
                            try:
                                deleted = mongo_db["worklog_entries"].delete_one({"_id": ObjectId(s)})
                            except Exception:
                                deleted = mongo_db["worklog_entries"].delete_one({"_id": s})

                            if deleted is not None and getattr(deleted, "deleted_count", 0) > 0:
                                st.success("‚úÖ Entrada borrada.")
                                st.rerun()
                            else:
                                st.error("‚ùå No se pudo borrar (id no encontrado).")
                        except Exception as e:
                            st.error(f"‚ùå Error borrando worklog: {e}")
    with tabs[1]:
        st.subheader("üìã Backlog (V4)")

        col_f1, col_f2, col_f3 = st.columns([2, 1, 1])
        with col_f1:
            flt_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted([p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]),
                index=0,
                key="backlog_filter_project",
            )
        with col_f2:
            flt_status = st.selectbox(
                "Status (filter)",
                options=["(all)", "Todo", "Doing", "Done", "Blocked", "Canceled"],
                index=0,
                key="backlog_filter_status",
            )
        with col_f3:
            flt_priority = st.selectbox(
                "Priority (filter)",
                options=["(all)", "Alta", "Media", "Baja"],
                index=0,
                key="backlog_filter_priority",
            )

        query = {}
        if flt_project != "(all)":
            query["project"] = flt_project
        if flt_status != "(all)":
            query["status"] = flt_status
        if flt_priority != "(all)":
            query["priority"] = flt_priority

        st.markdown("### ‚ûï Crear backlog item")

        # Nota: usamos form + submit button expl√≠cito (sin submits impl√≠citos por Enter).
        with st.form("backlog_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                b_project = st.text_input("Project", value=flt_project if flt_project != "(all)" else "")
                b_module = st.text_input("Module (optional)", value="")
                b_owner = st.text_input("Owner", value=os.getenv("USER", "") or "user")
                b_priority = st.selectbox("Priority", ["Alta", "Media", "Baja"], index=1)
                b_status = st.selectbox("Status", ["Todo", "Doing", "Done", "Blocked", "Canceled"], index=0)

            with c2:
                b_task = st.text_input("Task (short)", value="")
                b_description = st.text_area("Description (optional)", value="", height=120)
                b_estimate = st.number_input("Estimate hours (optional)", min_value=0.0, value=0.0, step=0.25)
                use_target = st.checkbox("Set target date", value=False)
                b_target_date = st.date_input("Target date", value=datetime.today(), disabled=not use_target)

            b_tags_csv = st.text_input("Tags (comma-separated)", value="")
            create_btn = st.form_submit_button("Guardar backlog item")

            if create_btn:
                b_project_s = (b_project or "").strip()
                b_task_s = (b_task or "").strip()
                b_owner_s = (b_owner or "").strip()

                if not b_project_s or not b_task_s or not b_owner_s:
                    st.error("‚ùå Campos requeridos: Project, Task, Owner.")
                else:
                    now = datetime.utcnow()
                    doc = {
                        "project": b_project_s,
                        "module": (b_module or "").strip() or None,
                        "task": b_task_s,
                        "description": (b_description or "").strip() or None,
                        "priority": b_priority,
                        "status": b_status,
                        "estimate_hours": float(b_estimate) if b_estimate and float(b_estimate) > 0 else None,
                        "owner": b_owner_s,
                        "target_date": b_target_date.strftime("%Y-%m-%d") if use_target else None,
                        "tags": [t.strip() for t in (b_tags_csv or "").split(",") if t.strip()],
                        "created_at": now,
                        "updated_at": now,
                    }

                    try:
                        mongo_db["backlog_items"].insert_one(doc)
                        st.success("‚úÖ Backlog item guardado.")
                    except Exception as e:
                        st.error(f"‚ùå Error guardando backlog item: {e}")

        st.markdown("---")
        st.markdown("### üìå Items (recientes)")

        try:
            items = list(
                mongo_db["backlog_items"]
                .find(query)
                .sort("updated_at", -1)
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog: {e}")
            items = []

        if not items:
            st.info("No hay backlog items para este filtro.")
        else:
            rows = []
            for it in items:
                rows.append(
                    {
                        "_id": str(it.get("_id")),
                        "project": it.get("project", ""),
                        "module": it.get("module", ""),
                        "task": it.get("task", ""),
                        "priority": it.get("priority", ""),
                        "status": it.get("status", ""),
                        "owner": it.get("owner", ""),
                        "target_date": it.get("target_date", ""),
                        "updated_at": it.get("updated_at", ""),
                    }
                )

            df = pd.DataFrame(rows)
            st.dataframe(df, width='stretch', hide_index=True)
            st.markdown("### ‚¨áÔ∏è Exportar Backlog a CSV (MVP)")
            st.caption("Selecciona items y desc√°rgalos como CSV. Por defecto se muestran los √≠tems recientes; opcionalmente puedes filtrar.")

            export_mode = st.selectbox(
                "Modo de exportaci√≥n",
                options=["Seleccionar de Recientes", "Consulta con filtros"],
                index=0,
                key="backlog_export_mode",
            )

            export_df = pd.DataFrame()

            if export_mode == "Seleccionar de Recientes":
                export_df = df.copy()
            else:
                with st.expander("Filtros", expanded=False):
                    c1, c2, c3 = st.columns(3)
                    with c1:
                        start_d = st.date_input("Desde", value=(date.today() - timedelta(days=7)), key="backlog_export_start")
                    with c2:
                        end_d = st.date_input("Hasta", value=date.today(), key="backlog_export_end")
                    with c3:
                        limit_n = st.number_input("L√≠mite", min_value=10, max_value=5000, value=500, step=50, key="backlog_export_limit")

                    # Opciones din√°micas (best-effort) desde MongoDB
                    try:
                        proj_opts = sorted([p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)])
                    except Exception:
                        proj_opts = []
                    try:
                        owner_opts = sorted([o for o in mongo_db["backlog_items"].distinct("owner") if isinstance(o, str)])
                    except Exception:
                        owner_opts = []

                    c4, c5, c6 = st.columns(3)
                    with c4:
                        flt_project2 = st.selectbox("Project", options=["(all)"] + proj_opts, index=0, key="backlog_export_project")
                    with c5:
                        flt_status2 = st.selectbox(
                            "Status",
                            options=["(all)", "Todo", "Doing", "Done", "Blocked", "Canceled"],
                            index=0,
                            key="backlog_export_status",
                        )
                    with c6:
                        flt_priority2 = st.selectbox(
                            "Priority",
                            options=["(all)", "Alta", "Media", "Baja"],
                            index=0,
                            key="backlog_export_priority",
                        )

                    c7, c8 = st.columns(2)
                    with c7:
                        flt_owner2 = st.selectbox("Owner", options=["(all)"] + owner_opts, index=0, key="backlog_export_owner")
                    with c8:
                        text_q = st.text_input("Contiene (task/description)", value="", key="backlog_export_text")

                start_dt = datetime(start_d.year, start_d.month, start_d.day, 0, 0, 0)
                end_dt = datetime(end_d.year, end_d.month, end_d.day, 23, 59, 59)

                q = {"updated_at": {"$gte": start_dt, "$lte": end_dt}}
                if flt_project2 != "(all)":
                    q["project"] = flt_project2
                if flt_status2 != "(all)":
                    q["status"] = flt_status2
                if flt_priority2 != "(all)":
                    q["priority"] = flt_priority2
                if flt_owner2 != "(all)":
                    q["owner"] = flt_owner2
                if (text_q or "").strip():
                    rx = {"$regex": re.escape(text_q.strip()), "$options": "i"}
                    q["$or"] = [{"task": rx}, {"description": rx}]

                try:
                    docs = list(
                        mongo_db["backlog_items"]
                        .find(q)
                        .sort([("updated_at", -1)])
                        .limit(int(limit_n))
                    )
                    rows2 = []
                    for it in docs:
                        rows2.append(
                            {
                                "_id": str(it.get("_id")),
                                "project": it.get("project", ""),
                                "module": it.get("module", ""),
                                "task": it.get("task", ""),
                                "priority": it.get("priority", ""),
                                "status": it.get("status", ""),
                                "owner": it.get("owner", ""),
                                "target_date": it.get("target_date", ""),
                                "updated_at": it.get("updated_at", ""),
                            }
                        )
                    export_df = pd.DataFrame(rows2)
                except Exception as e:
                    st.error(f"‚ùå Error preparando exportaci√≥n: {e}")
                    export_df = pd.DataFrame()

            if export_df.empty:
                st.info("No hay filas para exportar con los criterios actuales.")
            else:
                if "select" not in export_df.columns:
                    export_df.insert(0, "select", False)

                edited_df = st.data_editor(
                    export_df,
                    use_container_width=True,
                    num_rows="fixed",
                    key="backlog_export_editor",
                )

                selected_df = edited_df[edited_df["select"] == True].drop(columns=["select"], errors="ignore")

                cdl1, cdl2 = st.columns([2, 1])
                with cdl1:
                    st.caption(f"Seleccionadas: {len(selected_df)} / {len(edited_df)}")
                with cdl2:
                    if len(selected_df) > 0:
                        csv_bytes = selected_df.to_csv(index=False).encode("utf-8")
                        fname = f"backlog_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
                        st.download_button(
                            "Descargar CSV",
                            data=csv_bytes,
                            file_name=fname,
                            mime="text/csv",
                            key="backlog_export_download",
                        )
                    else:
                        st.button("Descargar CSV", disabled=True, key="backlog_export_download_disabled")

            st.markdown("### ‚úèÔ∏è Actualizar item")
            options = [
                (r["_id"], f"[{r['status']}] {r['project']} ‚Äî {r['task']}")
                for r in rows
            ]
            selected_id = st.selectbox(
                "Selecciona un item",
                options=[o[0] for o in options],
                format_func=lambda x: dict(options).get(x, x),
                key="backlog_select_item",
            )

            # Obtener el documento actual
            current = None
            try:
                current = _find_one_by_id(mongo_db["backlog_items"], selected_id)
            except Exception:
                current = None

            if current is None:
                st.warning("No se pudo cargar el item seleccionado.")
            else:
                u1, u2, u3 = st.columns([1, 1, 1])
                with u1:
                    new_status = st.selectbox(
                        "New status",
                        ["Todo", "Doing", "Done", "Blocked", "Canceled"],
                        index=["Todo", "Doing", "Done", "Blocked", "Canceled"].index(current.get("status", "Todo"))
                        if current.get("status") in ["Todo", "Doing", "Done", "Blocked", "Canceled"] else 0,
                        key="backlog_update_status",
                    )
                with u2:
                    new_priority = st.selectbox(
                        "New priority",
                        ["Alta", "Media", "Baja"],
                        index=["Alta", "Media", "Baja"].index(current.get("priority", "Media"))
                        if current.get("priority") in ["Alta", "Media", "Baja"] else 1,
                        key="backlog_update_priority",
                    )
                with u3:
                    new_owner = st.text_input(
                        "Owner",
                        value=current.get("owner", ""),
                        key="backlog_update_owner",
                    )

                upd_task = st.text_input("Task", value=current.get("task", ""), key="backlog_update_task")
                upd_desc = st.text_area(
                    "Description",
                    value=current.get("description") or "",
                    height=120,
                    key="backlog_update_desc",
                )

                u_tags = st.text_input(
                    "Tags (comma-separated)",
                    value=", ".join(current.get("tags", []) or []),
                    key="backlog_update_tags",
                )

                save_update = st.button("Guardar cambios", key="backlog_save_changes")
                if save_update:
                    try:
                        now = datetime.utcnow()
                        set_doc = {
                            "status": new_status,
                            "priority": new_priority,
                            "owner": (new_owner or "").strip() or "user",
                            "task": (upd_task or "").strip(),
                            "description": (upd_desc or "").strip() or None,
                            "tags": [t.strip() for t in (u_tags or "").split(",") if t.strip()],
                            "updated_at": now,
                        }
                        # Timestamp estable de "completado"
                        if (current.get("status") != "Done") and (new_status == "Done"):
                            set_doc["done_at"] = now
                        elif (current.get("status") == "Done") and (new_status != "Done"):
                            set_doc["done_at"] = None

                        mongo_db["backlog_items"].update_one(
                            {"_id": current["_id"]},
                            {"$set": set_doc},
                        )
                        st.success("‚úÖ Cambios guardados.")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Error actualizando backlog item: {e}")

    with tabs[2]:
        st.subheader("üìÖ Weekly Review (V5)")

        weekly_col = mongo_db["weekly_reviews"]

        today = date.today()
        iso_now = today.isocalendar()
        default_iso_year = int(iso_now.year)
        default_iso_week = int(iso_now.week)
        def _week_bounds(y: int, w: int):
            ws = date.fromisocalendar(int(y), int(w), 1)
            we = ws + timedelta(days=7)  # exclusivo
            start_dt = datetime(ws.year, ws.month, ws.day)
            end_dt = datetime(we.year, we.month, we.day)
            return ws, we, start_dt, end_dt

        def _weekly_metrics(y: int, w: int) -> dict:
            """Best-effort: calcula m√©tricas derivadas para una semana ISO."""
            out = {"real_hours": None, "tasks_done": None, "worklog_n": None, "worklog_tasks": None}
            # Worklog: suma de horas + conteo + preview de tasks
            try:
                pipe = [
                    {"$match": {"iso_year": int(y), "iso_week": int(w)}},
                    {"$group": {"_id": None, "h": {"$sum": "$hours"}, "n": {"$sum": 1}}},
                ]
                agg = list(mongo_db["worklog_entries"].aggregate(pipe))
                if agg:
                    out["real_hours"] = float(agg[0].get("h") or 0.0)
                    out["worklog_n"] = int(agg[0].get("n") or 0)
                else:
                    out["real_hours"] = 0.0
                    out["worklog_n"] = 0

                tdocs = list(
                    mongo_db["worklog_entries"]
                    .find({"iso_year": int(y), "iso_week": int(w)}, {"task": 1, "date": 1})
                    .sort([("date", -1), ("created_at", -1)])
                    .limit(8)
                )
                tasks = [str(t.get("task")).strip() for t in tdocs if str(t.get("task", "")).strip()]
                out["worklog_tasks"] = "; ".join(tasks) if tasks else ""
            except Exception:
                pass

            # Backlog Done: preferir done_at si existe; fallback a updated_at para legacy
            try:
                _ws, _we, start_dt, end_dt = _week_bounds(y, w)
                q_done = {
                    "status": "Done",
                    "$or": [
                        {"done_at": {"$gte": start_dt, "$lt": end_dt}},
                        {"$and": [{"done_at": {"$exists": False}}, {"updated_at": {"$gte": start_dt, "$lt": end_dt}}]},
                        {"$and": [{"done_at": None}, {"updated_at": {"$gte": start_dt, "$lt": end_dt}}]},
                    ],
                }
                out["tasks_done"] = int(mongo_db["backlog_items"].count_documents(q_done))
            except Exception:
                pass

            return out

        #st.markdown("### üßæ Weekly Reviews (recientes)")
        #st.caption("Selecciona una semana previa para cargarla en el editor (ISO year/week).")

        #try:
        #    recent_weekly = list(
        #        weekly_col.find({}, {"iso_year": 1, "iso_week": 1, "updated_at": 1})
        #        .sort("updated_at", -1)
        #        .limit(80)
        #    )
        #except Exception as e:
        #    st.error(f"‚ùå Error cargando weekly reviews recientes: {e}")
        #    recent_weekly = []

        #if recent_weekly:
        #    # Tabla m√≠nima
        #    df_weekly_recent = []
        #    for r in recent_weekly:
        #        rr = dict(r)
        #        rr["_id"] = str(rr.get("_id"))
        #        df_weekly_recent.append(rr)

        #    df_wr = pd.DataFrame(df_weekly_recent)
        #    # Ordena columnas si est√°n presentes
        #    cols_pref = [c for c in ["iso_year", "iso_week", "real_hours", "tasks_done", "worklog_n", "worklog_tasks", "updated_at", "_id"] if c in df_wr.columns]
        #    df_wr = df_wr[cols_pref] if cols_pref else df_wr
        #    st.dataframe(df_wr, width="stretch")

            # Selector simple para cargar
        #    opt_labels = []
        #    opt_map = {}
        #    for r in recent_weekly:
        #        y = r.get("iso_year")
        #        w = r.get("iso_week")
        #        upd = r.get("updated_at") or ""
        #        lab = f"{y}-W{int(w):02d}  ¬∑  {upd}"
        #        opt_labels.append(lab)
        #        opt_map[lab] = {"iso_year": int(y), "iso_week": int(w)}

        #    sel_lab = st.selectbox(
        #        "Selecciona una semana",
        #        options=opt_labels,
        #        index=0,
        #        key="weekly_recent_select",
        #    )
        #    if st.button("Cargar", key="weekly_recent_load_btn"):
        #        picked = opt_map.get(sel_lab) or {}
        #        if picked:
        #            st.session_state["weekly_iso_year"] = int(picked.get("iso_year"))
        #            st.session_state["weekly_iso_week"] = int(picked.get("iso_week"))
        #            st.rerun()
        #else:
        #    st.info("No hay weekly reviews recientes a√∫n.")

        st.divider()

        # --- Edici√≥n expl√≠cita de Weekly Reviews existentes (MVP) ---
        # Nota: El editor principal (ISO year/week) ya permite actualizar por upsert,
        # pero este apartado hace el flujo "Editar" expl√≠cito, similar a Worklog/Backlog.
        st.markdown("### ‚úèÔ∏è Editar Weekly Review (existente)")
        st.caption("Selecciona una Weekly Review existente para cargarla en el editor (ISO year/week) y modificarla.")

        try:
            weekly_edit_rows = list(
                weekly_col.find(
                    {},
                    {
                        "iso_year": 1,
                        "iso_week": 1,
                        "updated_at": 1,
                        "_id": 1,
                    },
                )
                .sort("updated_at", -1)
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando weekly reviews para edici√≥n: {e}")
            weekly_edit_rows = []

        if weekly_edit_rows:
            edit_labels = []
            edit_map = {}
            for d in weekly_edit_rows:
                y = d.get("iso_year")
                w = d.get("iso_week")
                upd = d.get("updated_at") or ""
                _id = str(d.get("_id"))
                lab = f"{y}-W{int(w):02d}  ¬∑  {upd}  ¬∑  {_id}"
                edit_labels.append(lab)
                edit_map[lab] = {"iso_year": int(y), "iso_week": int(w), "_id": _id}

            sel_edit = st.selectbox(
                "Selecciona una Weekly Review para editar",
                options=edit_labels,
                index=0,
                key="weekly_edit_select",
            )

            col_e1, col_e2 = st.columns([1, 1])
            with col_e1:
                if st.button("Cargar en editor", key="weekly_edit_load_btn"):
                    picked = edit_map.get(sel_edit) or {}
                    if picked:
                        st.session_state["weekly_iso_year"] = int(picked.get("iso_year"))
                        st.session_state["weekly_iso_week"] = int(picked.get("iso_week"))
                        st.session_state["weekly_edit_loaded_id"] = str(picked.get("_id") or "")
                        st.rerun()

            with col_e2:
                # Borrado opcional (por _id), seguro por confirmaci√≥n
                st.write("")
                st.write("")
                confirm_del = st.checkbox("Estoy seguro (borrar)", key="weekly_delete_confirm")
                typed_del = st.text_input("Escribe BORRAR", value="", key="weekly_delete_typed")
                if st.button("Borrar Weekly Review", key="weekly_delete_btn"):
                    if not confirm_del or typed_del.strip().upper() != "BORRAR":
                        st.error("Confirmaci√≥n incompleta. Marca el checkbox y escribe BORRAR.")
                    else:
                        picked = edit_map.get(sel_edit) or {}
                        del_id = picked.get("_id")
                        if not del_id:
                            st.error("No se encontr√≥ _id para borrar.")
                        else:
                            try:
                                # Soporta ObjectId y string id
                                try:
                                    weekly_col.delete_one({"_id": ObjectId(str(del_id))})
                                except Exception:
                                    weekly_col.delete_one({"_id": str(del_id)})
                                st.success("‚úÖ Weekly Review borrada.")
                                # Si estabas editando esa misma, limpia selecci√≥n
                                if st.session_state.get("weekly_edit_loaded_id") == str(del_id):
                                    st.session_state["weekly_edit_loaded_id"] = ""
                                st.rerun()
                            except Exception as e:
                                st.error(f"‚ùå Error borrando weekly review: {e}")
        else:
            st.info("No hay weekly reviews suficientes para editar todav√≠a.")

        st.divider()

        st.markdown("### ‚úèÔ∏è Editor Weekly Review")
        ebc1, ebc2 = st.columns([1, 1])
        with ebc1:
            if st.button("‚ûï Nueva Weekly Review (limpiar)", key="weekly_new_btn"):
                st.session_state["weekly_iso_year"] = default_iso_year
                st.session_state["weekly_iso_week"] = default_iso_week
                # Limpia el editor (texto) y overrides; √∫til para crear una nueva semana sin residuos.
                st.session_state["weekly_editor_loaded_key"] = ""
                st.session_state["weekly_editor_loaded_id"] = ""
                st.session_state["weekly_objectives_txt"] = ""
                st.session_state["weekly_wins_txt"] = ""
                st.session_state["weekly_blocks_risks_txt"] = ""
                st.session_state["weekly_plan_next_week_txt"] = ""
                st.session_state["weekly_override_metrics"] = False
                st.session_state["weekly_manual_real_hours"] = 0.0
                st.session_state["weekly_manual_tasks_done"] = 0
                st.rerun()
        with ebc2:
            if st.button("üîÑ Recargar desde BD", key="weekly_reload_btn"):
                # Fuerza recarga del documento actual en el editor.
                st.session_state["weekly_editor_loaded_key"] = ""
                st.session_state["weekly_editor_loaded_id"] = ""
                st.rerun()

        c1, c2 = st.columns(2)
        with c1:
            iso_year = st.number_input(
                "ISO Year",
                min_value=2000,
                max_value=2100,
                value=default_iso_year,
                step=1,
                key="weekly_iso_year",
            )
        with c2:
            iso_week = st.number_input(
                "ISO Week",
                min_value=1,
                max_value=53,
                value=default_iso_week,
                step=1,
                key="weekly_iso_week",
            )

        weekly_doc = None
        try:
            weekly_doc = weekly_col.find_one({"iso_year": int(iso_year), "iso_week": int(iso_week)})
        except Exception as e:
            st.error(f"‚ùå Error leyendo weekly review: {e}")

        def _join_lines(arr):
            if not arr:
                return ""
            if isinstance(arr, str):
                return arr
            return "\n".join([str(x) for x in arr if str(x).strip()])

        # --- Carga/edici√≥n: sincronizar el editor con el documento seleccionado ---
        # Nota: Streamlit mantiene el valor de widgets por `key`. Si cambias iso_year/iso_week,
        # el `value=` del widget NO sobreescribe autom√°ticamente el session_state existente.
        # Por eso, al cambiar de semana, reseteamos los campos del editor con los valores de BD.
        weekly_editor_key = f"{int(iso_year)}-{int(iso_week)}"
        weekly_editor_id = str((weekly_doc or {}).get("_id") or "")
        if (st.session_state.get("weekly_editor_loaded_key") != weekly_editor_key) or (st.session_state.get("weekly_editor_loaded_id") != weekly_editor_id):
            st.session_state["weekly_editor_loaded_key"] = weekly_editor_key
            st.session_state["weekly_editor_loaded_id"] = weekly_editor_id
            st.session_state["weekly_objectives_txt"] = _join_lines((weekly_doc or {}).get("weekly_objectives"))
            st.session_state["weekly_wins_txt"] = _join_lines((weekly_doc or {}).get("wins"))
            st.session_state["weekly_blocks_risks_txt"] = _join_lines((weekly_doc or {}).get("blocks_risks"))
            st.session_state["weekly_plan_next_week_txt"] = _join_lines((weekly_doc or {}).get("plan_next_week"))


        weekly_objectives_txt = st.text_area(
            "Objetivos de la semana (1 por l√≠nea)",
            value=str(st.session_state.get("weekly_objectives_txt", "")),
            height=120,
            placeholder="- Terminar MVP V4\n- Revisar paper X\n- Debug de microservicio Y",
            key="weekly_objectives_txt",
        )
        wins_txt = st.text_area(
            "Wins (1 por l√≠nea)",
            value=str(st.session_state.get("weekly_wins_txt", "")),
            height=120,
            placeholder="- Se aplic√≥ patch sin conflictos\n- Se resolvi√≥ bug de concurrencia",
            key="weekly_wins_txt",
        )
        blocks_risks_txt = st.text_area(
            "Bloqueos / riesgos (1 por l√≠nea)",
            value=str(st.session_state.get("weekly_blocks_risks_txt", "")),
            height=120,
            placeholder="- Falta contexto de archivo real\n- Riesgo de romper export a Quarto",
            key="weekly_blocks_risks_txt",
        )
        plan_next_week_txt = st.text_area(
            "Plan pr√≥xima semana (1 por l√≠nea)",
            value=str(st.session_state.get("weekly_plan_next_week_txt", "")),
            height=120,
            placeholder="- Implementar V5 completo\n- Documentar decisiones\n- Preparar clase",
            key="weekly_plan_next_week_txt",
        )

        def _split_lines(txt: str):
            return [ln.strip() for ln in (txt or "").splitlines() if ln.strip()]

        # Agregados autom√°ticos (best-effort)
        real_hours = None
        try:
            pipe = [
                {"$match": {"iso_year": int(iso_year), "iso_week": int(iso_week)}},
                {"$group": {"_id": None, "h": {"$sum": "$hours"}}},
            ]
            agg = list(mongo_db["worklog_entries"].aggregate(pipe))
            real_hours = float(agg[0]["h"]) if agg else 0.0
        except Exception:
            real_hours = None

        tasks_completed_count = None
        try:
            week_start = date.fromisocalendar(int(iso_year), int(iso_week), 1)
            week_end = week_start + timedelta(days=7)  # exclusivo
            tasks_completed_count = int(
                mongo_db["backlog_items"].count_documents(
                    {
                        "status": "Done",
                        # Prefer done_at (m√°s estable). Fallback a updated_at para items antiguos.
                        "$or": [
                            {
                                "done_at": {
                                    "$gte": datetime(week_start.year, week_start.month, week_start.day),
                                    "$lt": datetime(week_end.year, week_end.month, week_end.day),
                                }
                            },
                            {
                                "done_at": None,
                                "updated_at": {
                                    "$gte": datetime(week_start.year, week_start.month, week_start.day),
                                    "$lt": datetime(week_end.year, week_end.month, week_end.day),
                                },
                            },
                        ],
                    }
                )
            )
        except Exception:
            tasks_completed_count = None

        m1, m2 = st.columns(2)
        with m1:
            st.metric(
                "Horas reales (worklog)",
                f"{real_hours:.2f}" if isinstance(real_hours, (int, float)) else "N/A",
            )
        with m2:
            st.metric(
                "Tareas Done (backlog)",
                tasks_completed_count if tasks_completed_count is not None else "N/A",
            )

        # --- Ajuste manual (opcional) ---
        # Por dise√±o, estas m√©tricas son derivadas (worklog/backlog). Si quieres poder
        # corregirlas manualmente (p.ej. backlog no tiene done_at hist√≥rico), habilita override.
        loaded_week_key = f"{int(iso_year)}-{int(iso_week)}"
        if st.session_state.get("weekly_metrics_loaded_key") != loaded_week_key:
            st.session_state["weekly_metrics_loaded_key"] = loaded_week_key
            st.session_state["weekly_override_metrics"] = bool((weekly_doc or {}).get("manual_override_metrics", False))
            st.session_state["weekly_manual_real_hours"] = float(
                (weekly_doc or {}).get("manual_real_hours", real_hours if isinstance(real_hours, (int, float)) else 0.0) or 0.0
            )
            st.session_state["weekly_manual_tasks_done"] = int(
                (weekly_doc or {}).get("manual_tasks_done", tasks_completed_count if tasks_completed_count is not None else 0) or 0
            )

        st.markdown("#### Ajuste manual de m√©tricas (opcional)")
        override_metrics = st.checkbox(
            "Sobrescribir m√©tricas autom√°ticas (Horas reales / Tareas Done)",
            value=bool(st.session_state.get("weekly_override_metrics", False)),
            key="weekly_override_metrics",
        )
        if override_metrics:
            oc1, oc2 = st.columns(2)
            with oc1:
                st.number_input(
                    "Horas reales (override)",
                    min_value=0.0,
                    step=0.25,
                    key="weekly_manual_real_hours",
                )
            with oc2:
                st.number_input(
                    "Tareas Done (override)",
                    min_value=0,
                    step=1,
                    key="weekly_manual_tasks_done",
                )

        st.divider()

        if st.button("Guardar Weekly Review", key="weekly_save_btn"):
            now = datetime.utcnow()
            doc = {
                "iso_year": int(iso_year),
                "iso_week": int(iso_week),
                "weekly_objectives": _split_lines(weekly_objectives_txt),
                "wins": _split_lines(wins_txt),
                "blocks_risks": _split_lines(blocks_risks_txt),
                "plan_next_week": _split_lines(plan_next_week_txt),
                "agg_real_hours": real_hours if isinstance(real_hours, (int, float)) else None,
                "agg_tasks_done": tasks_completed_count,
                "manual_override_metrics": bool(st.session_state.get("weekly_override_metrics", False)),
                "manual_real_hours": float(st.session_state.get("weekly_manual_real_hours", 0.0)) if st.session_state.get("weekly_override_metrics") else None,
                "manual_tasks_done": int(st.session_state.get("weekly_manual_tasks_done", 0)) if st.session_state.get("weekly_override_metrics") else None,
                "updated_at": now,
            }

            try:
                weekly_col.update_one(
                    {"iso_year": int(iso_year), "iso_week": int(iso_week)},
                    {"$set": doc, "$setOnInsert": {"created_at": now}},
                    upsert=True,
                )
                st.success("‚úÖ Weekly Review guardada.")
                st.rerun()
            except Exception as e:
                st.error(f"‚ùå Error guardando Weekly Review: {e}")


        st.divider()
        st.markdown("### ‚¨áÔ∏è Exportar Weekly Review a CSV (MVP)")
        st.caption("Mismo patr√≥n que Worklog/Backlog: seleccionar filas y descargar CSV. Por defecto se muestran las weekly reviews recientes; opcionalmente puedes filtrar.")

        export_mode = st.selectbox(
            "Modo de exportaci√≥n",
            options=["Seleccionar de Recientes", "Consulta con filtros"],
            index=0,
            key="weekly_export_mode",
        )

        export_df = pd.DataFrame()

        if export_mode == "Seleccionar de Recientes":
            if "df_wr" in locals() and isinstance(df_wr, pd.DataFrame) and not df_wr.empty:  # noqa: F821
                export_df = df_wr.copy()  # noqa: F821
            else:
                try:
                    docs = list(
                        weekly_col.find({}, {"iso_year": 1, "iso_week": 1, "weekly_objectives": 1, "wins": 1, "blocks_risks": 1, "plan_next_week": 1, "updated_at": 1})
                        .sort("updated_at", -1)
                        .limit(80)
                    )
                    norm = []
                    for d in docs:
                        dd = dict(d)
                        dd["_id"] = str(dd.get("_id"))
                        norm.append(dd)
                    export_df = pd.DataFrame(norm)
                except Exception as e:
                    st.error(f"‚ùå Error preparando exportaci√≥n (recientes): {e}")
                    export_df = pd.DataFrame()
        else:
            with st.expander("Filtros", expanded=False):
                c1, c2, c3 = st.columns(3)
                with c1:
                    start_d = st.date_input("Desde", value=(date.today() - timedelta(days=30)), key="weekly_export_start")
                with c2:
                    end_d = st.date_input("Hasta", value=date.today(), key="weekly_export_end")
                with c3:
                    limit_n = st.number_input("L√≠mite", min_value=10, max_value=5000, value=500, step=50, key="weekly_export_limit")

                c4, c5, c6 = st.columns(3)
                with c4:
                    try:
                        years = sorted([int(y) for y in weekly_col.distinct("iso_year") if str(y).isdigit()])
                    except Exception:
                        years = []
                    flt_year = st.selectbox("ISO Year", options=["(all)"] + [str(y) for y in years], index=0, key="weekly_export_year")
                with c5:
                    flt_week = st.selectbox("ISO Week", options=["(all)"] + [str(w) for w in range(1, 54)], index=0, key="weekly_export_week")
                with c6:
                    text_q = st.text_input("Contiene (objetivos/wins/bloqueos/plan)", value="", key="weekly_export_text")

            start_dt = datetime(start_d.year, start_d.month, start_d.day)
            end_dt = datetime(end_d.year, end_d.month, end_d.day) + timedelta(days=1)  # exclusivo

            q = {"updated_at": {"$gte": start_dt, "$lt": end_dt}}
            if flt_year != "(all)":
                q["iso_year"] = int(flt_year)
            if flt_week != "(all)":
                q["iso_week"] = int(flt_week)
            if (text_q or "").strip():
                rx = {"$regex": re.escape(text_q.strip()), "$options": "i"}
                q["$or"] = [
                    {"weekly_objectives": rx},
                    {"wins": rx},
                    {"blocks_risks": rx},
                    {"plan_next_week": rx},
                ]

            try:
                docs = list(
                    weekly_col.find(
                        q,
                        {
                            "iso_year": 1,
                            "iso_week": 1,
                            "weekly_objectives": 1,
                            "wins": 1,
                            "blocks_risks": 1,
                            "plan_next_week": 1,
                            "updated_at": 1,
                        },
                    )
                    .sort("updated_at", -1)
                    .limit(int(limit_n))
                )
                norm = []
                for d in docs:
                    dd = dict(d)
                    dd["_id"] = str(dd.get("_id"))
                    norm.append(dd)
                export_df = pd.DataFrame(norm)
            except Exception as e:
                st.error(f"‚ùå Error preparando exportaci√≥n: {e}")
                export_df = pd.DataFrame()

        try:
            if not export_df.empty and {'iso_year', 'iso_week'}.issubset(set(export_df.columns)):
                rows = export_df.to_dict(orient='records')
                for rr in rows:
                    m = _weekly_metrics(rr.get('iso_year'), rr.get('iso_week'))
                    rr.update(m)
                export_df = pd.DataFrame(rows)
        except Exception as e:
            st.error(f"‚ùå Error calculando m√©tricas para export: {e}")

        if export_df.empty:
            st.info("No hay filas para exportar con los criterios actuales.")
        else:
            if "_id" in export_df.columns:
                export_df["_id"] = export_df["_id"].astype(str)

            if "select" not in export_df.columns:
                export_df.insert(0, "select", False)

            edited_df = st.data_editor(
                export_df,
                use_container_width=True,
                num_rows="fixed",
                key="weekly_export_editor",
            )

            selected_df = edited_df[edited_df["select"] == True].drop(columns=["select"], errors="ignore")

            cdl1, cdl2 = st.columns([2, 1])
            with cdl1:
                st.caption(f"Seleccionadas: {len(selected_df)} / {len(edited_df)}")
            with cdl2:
                if len(selected_df) > 0:
                    csv_bytes = selected_df.to_csv(index=False).encode("utf-8")
                    fname = f"weekly_reviews_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
                    st.download_button(
                        "Descargar CSV",
                        data=csv_bytes,
                        file_name=fname,
                        mime="text/csv",
                        key="weekly_export_download",
                    )
                else:
                    st.button("Descargar CSV", disabled=True, key="weekly_export_download_disabled")
    with tabs[3]:
        st.subheader("üì¶ Deliverables (V6)")

        deliverables_col = mongo_db["deliverables"]

        st.markdown("### ‚ûï Registrar entregable")

        with st.form("deliverables_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                d_date = st.date_input("Fecha", value=date.today())
                d_project = st.text_input("Proyecto")
                d_type = st.selectbox(
                    "Tipo",
                    ["reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                    index=0,
                    )
                d_deliverable = st.text_input("Deliverable (nombre)")

            with c2:
                d_path = st.text_input("Ruta / URL")
                d_commit = st.text_input("Commit ref (opcional)")
                d_tags_csv = st.text_input("Tags (comma-separated)")

            d_notes = st.text_area("Notas (opcional)", height=120)
            save_deliv = st.form_submit_button("Guardar entregable")

        if save_deliv:
            if not d_project.strip() or not d_deliverable.strip() or not d_path.strip():
                st.error("‚ùå Campos requeridos: Proyecto, Deliverable y Ruta / URL.")
            else:
                now = datetime.utcnow()
                doc = {
                    "date": d_date.strftime("%Y-%m-%d"),
                    "project": d_project.strip(),
                    "deliverable": d_deliverable.strip(),
                    "type": d_type,
                    "url_or_path": d_path.strip(),
                    "notes": d_notes.strip() or None,
                    "linked_worklog_ids": [],
                    "linked_note_ids": [],
                    "commit_ref": d_commit.strip() or None,
                    "linked_commits": [d_commit.strip()] if d_commit.strip() else [],
                    "tags": [t.strip() for t in d_tags_csv.split(",") if t.strip()],
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    deliverables_col.insert_one(doc)
                    st.success("‚úÖ Deliverable registrado.")
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando deliverable: {e}")

        st.divider()
        st.markdown("### üìÑ Entregables recientes")

        f1, f2, f3 = st.columns([2, 1, 1])
        with f1:
            flt_project = st.text_input("Project (filter)", value="")
        with f2:
            flt_type = st.selectbox(
                "Type (filter)",
                options=["(all)", "reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                index=0,
            )
        with f3:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=50, step=5)

        query = {}
        if flt_project.strip():
            query["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_type != "(all)":
            query["type"] = flt_type

        try:
            rows = list(
                deliverables_col.find(query)
                .sort([("date", -1), ("created_at", -1)])
                .limit(int(limit))
            )
            if not rows:
                st.info("No hay entregables para este filtro.")
            else:
                norm = []
                for r in rows:
                    rr = dict(r)
                    rr["_id"] = str(rr.get("_id"))
                    norm.append(rr)
                df_deliv_recent = pd.DataFrame(norm)
                st.dataframe(df_deliv_recent, width='stretch')
        except Exception as e:
            st.error(f"‚ùå Error cargando deliverables: {e}")


        st.divider()
        st.markdown("### ‚¨áÔ∏è Exportar Deliverables a CSV (MVP)")
        st.caption("Mismo patr√≥n que Worklog/Backlog: seleccionar filas y descargar CSV. Por defecto se muestran los entregables recientes; opcionalmente puedes filtrar.")
        
        
        export_mode = st.selectbox(
            "Modo de exportaci√≥n",
            options=["Seleccionar de Recientes", "Consulta con filtros"],
            index=0,
            key="deliverables_export_mode",
        )

        export_df = pd.DataFrame()

        if export_mode == "Seleccionar de Recientes":
            if "df_deliv_recent" in locals() and isinstance(df_deliv_recent, pd.DataFrame) and not df_deliv_recent.empty:
                export_df = df_deliv_recent.copy()
            else:
                export_df = pd.DataFrame()
        else:
            with st.expander("Filtros", expanded=False):
                c1, c2, c3 = st.columns(3)
                with c1:
                    start_d = st.date_input("Desde", value=(date.today() - timedelta(days=30)), key="deliverables_export_start")
                with c2:
                    end_d = st.date_input("Hasta", value=date.today(), key="deliverables_export_end")
                with c3:
                    limit_n = st.number_input("L√≠mite", min_value=10, max_value=5000, value=500, step=50, key="deliverables_export_limit")

                c4, c5, c6 = st.columns(3)
                with c4:
                    try:
                        proj_opts = sorted([p for p in deliverables_col.distinct("project") if isinstance(p, str)])
                    except Exception:
                        proj_opts = []
                    flt_project = st.selectbox("Proyecto", options=["(all)"] + proj_opts, index=0, key="deliverables_export_project")
                with c5:
                    flt_type = st.selectbox(
                        "Tipo",
                        options=["(all)", "reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                        index=0,
                        key="deliverables_export_type",
                    )
                with c6:
                    text_q = st.text_input("Contiene (nombre/notas/ruta)", value="", key="deliverables_export_text")

            start_dt = datetime(start_d.year, start_d.month, start_d.day)
            end_dt = datetime(end_d.year, end_d.month, end_d.day) + timedelta(days=1)  # exclusivo

            q = {"updated_at": {"$gte": start_dt, "$lt": end_dt}}
            if flt_project != "(all)":
                q["project"] = flt_project
            if flt_type != "(all)":
                q["type"] = flt_type
            if (text_q or "").strip():
                rx = {"$regex": re.escape(text_q.strip()), "$options": "i"}
                q["$or"] = [{"deliverable": rx}, {"notes": rx}, {"url_or_path": rx}]

            try:
                docs = list(
                    deliverables_col.find(q)
                    .sort("updated_at", -1)
                    .limit(int(limit_n))
                )
                norm = []
                for d in docs:
                    dd = dict(d)
                    dd["_id"] = str(dd.get("_id"))
                    norm.append(dd)
                export_df = pd.DataFrame(norm)
            except Exception as e:
                st.error(f"‚ùå Error preparando exportaci√≥n: {e}")
                export_df = pd.DataFrame()

        if export_df.empty:
            st.info("No hay filas para exportar con los criterios actuales.")
        else:
            if "_id" in export_df.columns:
                export_df["_id"] = export_df["_id"].astype(str)

            if "select" not in export_df.columns:
                export_df.insert(0, "select", False)

            edited_df = st.data_editor(
                export_df,
                use_container_width=True,
                num_rows="fixed",
                key="deliverables_export_editor",
            )

            selected_df = edited_df[edited_df["select"] == True].drop(columns=["select"], errors="ignore")

            cdl1, cdl2 = st.columns([2, 1])
            with cdl1:
                st.caption(f"Seleccionadas: {len(selected_df)} / {len(edited_df)}")
            with cdl2:
                if len(selected_df) > 0:
                    csv_bytes = selected_df.to_csv(index=False).encode("utf-8")
                    fname = f"deliverables_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.csv"
                    st.download_button(
                        "Descargar CSV",
                        data=csv_bytes,
                        file_name=fname,
                        mime="text/csv",
                        key="deliverables_export_download",
                    )
                else:
                    st.button("Descargar CSV", disabled=True, key="deliverables_export_download_disabled")
        st.divider()
        st.markdown("### ‚úèÔ∏è Editar entregable (MVP)")

        # Carga r√°pida desde los recientes (si ya se consultaron), si no vuelve a consultar.
        deliv_rows = []
        try:
            if "rows" in locals() and isinstance(rows, list) and rows:
                deliv_rows = rows
            else:
                deliv_rows = list(
                    deliverables_col.find({})
                    .sort([("date", -1), ("created_at", -1)])
                    .limit(200)
                )
        except Exception as e:
            st.error(f"‚ùå Error cargando entregables para edici√≥n: {e}")
            deliv_rows = []

        if not deliv_rows:
            st.info("No hay entregables suficientes para editar.")
        else:
            opt_labels = []
            opt_map = {}
            for d in deliv_rows:
                _id = str(d.get("_id"))
                d_date = d.get("date") or ""
                d_proj = d.get("project") or "‚Äî"
                d_name = d.get("deliverable") or "(sin nombre)"
                d_type = d.get("type") or "‚Äî"
                lab = f"{d_date} [{d_type}] {d_proj} ‚Äî {d_name}"
                opt_labels.append(lab)
                opt_map[lab] = _id

            selected_label = st.selectbox(
                "Selecciona un entregable para editar",
                options=opt_labels,
                index=0,
                key="deliverables_edit_select",
            )
            sel_id = opt_map.get(selected_label)

            if st.button("Cargar", key="deliverables_edit_load_btn"):
                st.session_state["deliverables_edit_id"] = sel_id or ""
                st.rerun()

            deliv_id = st.session_state.get("deliverables_edit_id") or sel_id
            doc = _find_one_by_id(deliverables_col, deliv_id) if deliv_id else None

            if not doc:
                st.warning("No se pudo cargar el entregable seleccionado.")
            else:
                loaded_id = st.session_state.get("deliverables_edit_loaded_id")
                current_id = str(doc.get("_id"))
                if loaded_id != current_id:
                    st.session_state["deliverables_edit_loaded_id"] = current_id
                    # date guardada como string YYYY-MM-DD
                    try:
                        st.session_state["deliverables_edit_date"] = datetime.strptime(doc.get("date") or "", "%Y-%m-%d").date()
                    except Exception:
                        st.session_state["deliverables_edit_date"] = date.today()
                    st.session_state["deliverables_edit_project"] = doc.get("project") or ""
                    st.session_state["deliverables_edit_type"] = doc.get("type") or "reporte"
                    st.session_state["deliverables_edit_deliverable"] = doc.get("deliverable") or ""
                    st.session_state["deliverables_edit_path"] = doc.get("url_or_path") or ""
                    st.session_state["deliverables_edit_commit"] = doc.get("commit_ref") or ""
                    st.session_state["deliverables_edit_tags"] = ", ".join(doc.get("tags") or [])
                    st.session_state["deliverables_edit_notes"] = doc.get("notes") or ""

                e1, e2 = st.columns(2)
                with e1:
                    e_date = st.date_input("Fecha", key="deliverables_edit_date")
                    e_project = st.text_input("Proyecto", key="deliverables_edit_project")
                    e_type = st.selectbox(
                        "Tipo",
                        ["reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                        index=["reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"].index(st.session_state.get("deliverables_edit_type", "reporte"))
                        if st.session_state.get("deliverables_edit_type", "reporte") in ["reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"]
                        else 0,
                        key="deliverables_edit_type",
                    )
                    e_deliv = st.text_input("Deliverable (nombre)", key="deliverables_edit_deliverable")
                with e2:
                    e_path = st.text_input("Ruta / URL", key="deliverables_edit_path")
                    e_commit = st.text_input("Commit ref (opcional)", key="deliverables_edit_commit")
                    e_tags_csv = st.text_input("Tags (comma-separated)", key="deliverables_edit_tags")

                e_notes = st.text_area("Notas (opcional)", height=140, key="deliverables_edit_notes")

                if st.button("Guardar cambios", key="deliverables_edit_save_btn"):
                    if not (e_project or "").strip() or not (e_deliv or "").strip() or not (e_path or "").strip():
                        st.error("‚ùå Campos requeridos: Proyecto, Deliverable y Ruta / URL.")
                    else:
                        now = datetime.utcnow()
                        upd = {
                            "date": e_date.strftime("%Y-%m-%d"),
                            "project": (e_project or "").strip(),
                            "deliverable": (e_deliv or "").strip(),
                            "type": e_type,
                            "url_or_path": (e_path or "").strip(),
                            "notes": (e_notes or "").strip() or None,
                            "commit_ref": (e_commit or "").strip() or None,
                            "linked_commits": [(e_commit or "").strip()] if (e_commit or "").strip() else [],
                            "tags": [t.strip() for t in (e_tags_csv or "").split(",") if t.strip()],
                            "updated_at": now,
                        }
                        res = _update_one_by_id(deliverables_col, current_id, {"$set": upd})
                        if res is not None and getattr(res, "matched_count", 0) > 0:
                            st.success("‚úÖ Entregable actualizado.")
                            st.rerun()
                        else:
                            st.error("‚ùå No se pudo actualizar (id no encontrado).")


    with tabs[4]:
        st.subheader("üß± Kanban (V7 ‚Äî m√≠nimo)")
        st.caption("Vista m√≠nima del backlog por columnas. Cambio de estado v√≠a selectbox (sin drag & drop).")

        kf1, kf2 = st.columns([2, 1])
        with kf1:
            kb_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted(
                    [p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]
                ),
                index=0,
                key="kanban_filter_project",
            )
        with kf2:
            if st.button("üîÑ Refrescar", key="kanban_refresh"):
                st.rerun()

        k_query = {}
        if kb_project != "(all)":
            k_query["project"] = kb_project

        try:
            k_items = list(
                mongo_db["backlog_items"]
                .find(k_query)
                .sort("updated_at", -1)
                .limit(400)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog (kanban): {e}")
            k_items = []

        statuses = ["Todo", "Doing", "Blocked", "Done"]
        grouped = {s: [] for s in statuses}
        for it in k_items:
            s = it.get("status", "Todo")
            if s not in grouped:
                # Ignora estados fuera del Kanban m√≠nimo (p.ej. Canceled)
                continue
            grouped[s].append(it)

        col_todo, col_doing, col_blocked, col_done = st.columns(4)
        cols = {
            "Todo": col_todo,
            "Doing": col_doing,
            "Blocked": col_blocked,
            "Done": col_done,
        }

        for s in statuses:
            with cols[s]:
                st.markdown(f"#### {s} ({len(grouped[s])})")

                if not grouped[s]:
                    st.info("‚Äî")
                    continue

                for it in grouped[s][:50]:
                    _id_str = str(it.get("_id"))
                    title = f"{it.get('project','')} ‚Äî {it.get('task','')}"
                    with st.expander(title, expanded=False):
                        meta_left, meta_right = st.columns([2, 1])
                        with meta_left:
                            st.write(f"**Module:** {it.get('module') or '‚Äî'}")
                            st.write(f"**Priority:** {it.get('priority') or '‚Äî'}")
                            st.write(f"**Owner:** {it.get('owner') or '‚Äî'}")
                            if it.get("target_date"):
                                st.write(f"**Target date:** {it.get('target_date')}")
                        with meta_right:
                            st.write(f"**Updated:** {it.get('updated_at') or '‚Äî'}")
                            st.write(f"**Id:** `{_id_str}`")

                        new_status = st.selectbox(
                            "Status",
                            options=statuses,
                            index=statuses.index(s),
                            key=f"kanban_status_{_id_str}",
                        )

                        apply_btn = st.button(
                            "Aplicar cambio",
                            key=f"kanban_apply_{_id_str}",
                            disabled=(new_status == s),
                        )

                        if apply_btn and new_status != s:
                            now = datetime.utcnow()
                            set_doc = {"status": new_status, "updated_at": now}
                            if (s != "Done") and (new_status == "Done"):
                                set_doc["done_at"] = now
                            elif (s == "Done") and (new_status != "Done"):
                                set_doc["done_at"] = None

                            res = _update_one_by_id(
                                mongo_db["backlog_items"],
                                _id_str,
                                {"$set": set_doc},
                            )
                            if res is not None and getattr(res, "matched_count", 0) > 0:
                                st.success("‚úÖ Estado actualizado.")
                                st.rerun()
                            else:
                                st.error("‚ùå No se pudo actualizar el estado (id no encontrado).")



    with tabs[5]:
        st.subheader("üìì Diario LaTeX (V8)")
        st.caption("Captura y consulta de notas largas en LaTeX. (Sin exportaci√≥n todav√≠a)")
        notes_col = mongo_db["latex_notes"]


        st.markdown("### ‚ûï Nueva nota")
        # --- Reset seguro del form "Nueva nota" (antes de instanciar widgets) ---
        if st.session_state.pop("diary_clear_new_form", False):
            for _k in ("diary_new_title", "diary_new_date", "diary_new_project", "diary_new_context", "diary_new_tags"):
                st.session_state.pop(_k, None)
            _keys = _get_editor_keys("diary_new")
            st.session_state.pop(_keys["text"], None)
            st.session_state[_keys["rev"]] = st.session_state.get(_keys["rev"], 0) + 1


        c1, c2 = st.columns([2, 1])
        with c1:
            n_title = st.text_input("T√≠tulo", key="diary_new_title")
        with c2:
            n_date = st.date_input("Fecha", value=date.today(), key="diary_new_date")
            n_project = st.text_input("Proyecto (opcional)", value="", key="diary_new_project")
            n_context = st.selectbox(
                "Contexto",
                options=["estudio", "debug", "lectura", "idea", "reflexion"],
                index=0,
                key="diary_new_context",
            )
            n_tags_raw = st.text_input("Tags (comma-separated)", value="", key="diary_new_tags")

        _render_latex_toolbar(prefix="diary_new")
        n_latex = _render_latex_ace_editor(prefix="diary_new", initial_text="", height=320)

        if st.button("Guardar nota", key="diary_new_save"):
            tags = _parse_tags_csv(n_tags_raw)
            if not (n_title or "").strip() or not (n_latex or "").strip():
                st.error("‚ö†Ô∏è T√≠tulo y contenido LaTeX son obligatorios.")
            else:
                doc = {
                    "title": n_title.strip(),
                    "date": n_date.strftime("%Y-%m-%d"),
                    "project": (n_project or "").strip(),
                    "context": n_context,
                    "tags": tags,
                    "latex_body": n_latex,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                }
                try:
                    notes_col.insert_one(doc)
                    st.success("‚úÖ Nota guardada.")
                    # Limpieza m√≠nima
                    # Limpiar el formulario en el siguiente rerun (evita modificar session_state despu√©s de instanciar widgets)
                    st.session_state["diary_clear_new_form"] = True
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando nota: {e}")
                    st.error(f"‚ùå Error guardando nota: {e}")

        st.divider()
        st.markdown("### üîé Buscar notas")

        f1, f2, f3, f4 = st.columns([2, 1, 1, 1])
        with f1:
            flt_q = st.text_input("Texto (t√≠tulo o cuerpo)", value="")
        with f2:
            flt_project = st.text_input("Proyecto", value="")
        with f3:
            flt_context = st.selectbox(
            "Contexto",
            options=["(all)", "estudio", "debug", "lectura", "idea", "reflexion"],
            index=0,
        )
        with f4:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=30, step=5)

        q = {}
        if flt_project.strip():
            q["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_context != "(all)":
            q["context"] = flt_context
        if flt_q.strip():
            rx = {"$regex": re.escape(flt_q.strip()), "$options": "i"}
            q["$or"] = [{"title": rx}, {"latex_body": rx}]

        try:
            notes = list(
            notes_col.find(q)
            .sort([("date", -1), ("updated_at", -1)])
            .limit(int(limit))
        )
        except Exception as e:
            st.error(f"‚ùå Error cargando notas: {e}")
            notes = []

        if not notes:
            st.info("No hay notas para este filtro.")
        else:
            for n in notes:
                nid = str(n.get("_id"))
                title = n.get("title") or "(sin t√≠tulo)"
                d = n.get("date") or ""
                proj = n.get("project") or "‚Äî"
                ctx = n.get("context") or "‚Äî"
                tags = ", ".join(n.get("tags") or [])

                with st.expander(f"{d} ‚Äî {title}", expanded=False):
                    meta1, meta2 = st.columns([2, 1])
                    with meta1:
                        st.write(f"**Proyecto:** {proj}")
                        st.write(f"**Contexto:** {ctx}")
                        if tags:
                            st.write(f"**Tags:** {tags}")
                    with meta2:
                        st.write(f"**Id:** `{nid}`")
                        st.write(f"**Updated:** {n.get('updated_at') or '‚Äî'}")

                    st.code(n.get("latex_body") or "", language="latex")



        st.divider()
        st.markdown("### ‚úèÔ∏è Editar nota")

        if not notes:
            st.info("No hay notas cargadas para editar con este filtro.")
        else:
            opt_map: Dict[str, str] = {}
            opt_labels: List[str] = []
            for n in notes:
                _nid = str(n.get("_id"))
                label = _note_label(n)
                opt_labels.append(label)
                opt_map[label] = _nid

            selected_label = st.selectbox(
                "Selecciona una nota para editar",
                options=opt_labels,
                index=0,
                key="diary_edit_select",
            )
            nid = opt_map.get(selected_label)
            note_doc = _find_one_by_id(notes_col, nid) if nid else None

            if not note_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                # Cargar valores al cambiar de selecci√≥n
                edit_prefix = "diary_edit"
                keys = _get_editor_keys(edit_prefix)
                if st.session_state.get(keys["loaded_id"]) != str(note_doc.get("_id")):
                    st.session_state[keys["loaded_id"]] = str(note_doc.get("_id"))
                    st.session_state["diary_edit_title"] = note_doc.get("title") or ""
                    # date guardada como string YYYY-MM-DD
                    try:
                        st.session_state["diary_edit_date"] = datetime.strptime(note_doc.get("date") or "", "%Y-%m-%d").date()
                    except Exception:
                        st.session_state["diary_edit_date"] = date.today()
                    st.session_state["diary_edit_project"] = note_doc.get("project") or ""
                    st.session_state["diary_edit_context"] = note_doc.get("context") or "estudio"
                    st.session_state["diary_edit_tags"] = ", ".join(note_doc.get("tags") or [])
                    st.session_state[keys["text"]] = note_doc.get("latex_body") or ""
                    st.session_state[keys["rev"]] = st.session_state.get(keys["rev"], 0) + 1

                e1, e2 = st.columns([2, 1])
                with e1:
                    e_title = st.text_input("T√≠tulo", key="diary_edit_title")
                with e2:
                    e_date = st.date_input("Fecha", key="diary_edit_date")
                    e_project = st.text_input("Proyecto (opcional)", key="diary_edit_project")
                    e_context = st.selectbox(
                        "Contexto",
                        options=["estudio", "debug", "lectura", "idea", "reflexion"],
                        index=["estudio", "debug", "lectura", "idea", "reflexion"].index(st.session_state.get("diary_edit_context", "estudio"))
                        if st.session_state.get("diary_edit_context", "estudio") in ["estudio", "debug", "lectura", "idea", "reflexion"]
                        else 0,
                        key="diary_edit_context",
                    )
                    e_tags_raw = st.text_input("Tags (comma-separated)", key="diary_edit_tags")

                _render_latex_toolbar(prefix=edit_prefix)
                e_latex = _render_latex_ace_editor(prefix=edit_prefix, initial_text=note_doc.get("latex_body") or "", height=420)

                if st.button("Guardar cambios", key="diary_edit_save"):
                    if not (e_title or "").strip() or not (e_latex or "").strip():
                        st.error("‚ö†Ô∏è T√≠tulo y contenido LaTeX son obligatorios.")
                    else:
                        tags = _parse_tags_csv(e_tags_raw)
                        upd = {
                            "title": e_title.strip(),
                            "date": e_date.strftime("%Y-%m-%d"),
                            "project": (e_project or "").strip(),
                            "context": e_context,
                            "tags": tags,
                            "latex_body": e_latex,
                            "updated_at": datetime.utcnow(),
                        }
                        try:
                            notes_col.update_one({"_id": ObjectId(nid)}, {"$set": upd})
                            st.success("‚úÖ Nota actualizada.")
                            st.rerun()
                        except Exception as e:
                            st.error(f"‚ùå Error actualizando nota: {e}")

        st.divider()
        st.markdown("### üóëÔ∏è Borrar nota")

        if not notes:
            st.info("No hay notas cargadas para borrar con este filtro.")
        else:
            del_opt_map: Dict[str, str] = {}
            del_opt_labels: List[str] = []
            for n in notes:
                _nid = str(n.get("_id"))
                label = _note_label(n)
                del_opt_labels.append(label)
                del_opt_map[label] = _nid

            del_selected = st.selectbox(
                "Selecciona una nota para borrar",
                options=del_opt_labels,
                index=0,
                key="diary_delete_select",
            )
            del_nid = del_opt_map.get(del_selected)
            del_doc = _find_one_by_id(notes_col, del_nid) if del_nid else None

            if not del_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                st.write(f"**T√≠tulo:** {del_doc.get('title') or '(sin t√≠tulo)'}")
                st.write(f"**Fecha:** {del_doc.get('date') or ''}")
                st.write(f"**Proyecto:** {del_doc.get('project') or '‚Äî'}")
                st.write(f"**Contexto:** {del_doc.get('context') or '‚Äî'}")
                preview = (del_doc.get("latex_body") or "")[:400]
                if preview:
                    st.code(preview, language="latex")

                confirm = st.checkbox("Estoy seguro", key="diary_delete_confirm")
                typed = st.text_input("Escribe BORRAR para confirmar", value="", key="diary_delete_typed")

                if st.button("Borrar definitivamente", key="diary_delete_btn"):
                    if not confirm or typed.strip().upper() != "BORRAR":
                        st.error("Confirmaci√≥n incompleta. Marca el checkbox y escribe BORRAR.")
                    else:
                        try:
                            notes_col.delete_one({"_id": ObjectId(del_nid)})
                            st.success("‚úÖ Nota borrada.")
                            st.rerun()
                        except Exception as e:
                            st.error(f"‚ùå Error borrando nota: {e}")
        st.markdown("#### üì§ Exportar")

        if not notes:
            st.info("Primero crea o filtra una nota para poder exportar.")
        else:
            # Selecci√≥n expl√≠cita de nota a exportar (evita variables fuera de scope)
            opt_labels = []
            opt_map = {}
            for n in notes:
                _nid = str(n.get("_id"))
                _d = n.get("date") or ""
                _t = n.get("title") or "(sin t√≠tulo)"
                label = f"{_d} ‚Äî {_t}"
                opt_labels.append(label)
                opt_map[label] = _nid

            selected_label = st.selectbox(
                "Selecciona una nota",
                options=opt_labels,
                index=0,
                key="latex_notes_export_select",
            )
            nid = opt_map.get(selected_label)
            note_doc = None
            if nid:
                note_doc = _find_one_by_id(notes_col, nid)

            if not note_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                e1, e2 = st.columns(2)

                with e1:
                    if st.button("Generar TEX", key=f"note_tex_gen_{nid}"):
                        st.session_state[f"note_tex_{nid}"] = generar_tex_nota_latex(note_doc)
                        st.success("‚úÖ TEX listo para descargar.")

                    tex_data = st.session_state.get(f"note_tex_{nid}")
                    if tex_data:
                        st.download_button(
                            "Descargar TEX",
                            data=tex_data,
                            file_name=f"latex_note_{nid}.tex",
                            mime="text/x-tex",
                            key=f"note_tex_dl_{nid}",
                        )

                with e2:
                    if st.button("Generar PDF", key=f"note_pdf_gen_{nid}"):
                        try:
                            pdf_path = generar_pdf_nota_latex(note_doc)
                            st.session_state[f"note_pdf_path_{nid}"] = pdf_path
                            st.success("‚úÖ PDF listo para descargar.")
                        except Exception as e:
                            st.error(f"‚ùå Error generando PDF: {e}")

                    pdf_path = st.session_state.get(f"note_pdf_path_{nid}")
                    if pdf_path and os.path.exists(pdf_path):
                        with open(pdf_path, "rb") as f:
                            st.download_button(
                                "Descargar PDF",
                                data=f.read(),
                                file_name=os.path.basename(pdf_path),
                                mime="application/pdf",
                                key=f"note_pdf_dl_{nid}",
                            )
