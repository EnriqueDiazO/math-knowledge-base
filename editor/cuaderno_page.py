"""
Auto-generated by scripts/split_cuaderno_page.py
Source: editor/editor_streamlit.py
Generated at: 2026-01-21T01:25:18.076642Z
"""

from __future__ import annotations

import os
import re
from collections import Counter
from datetime import date
from datetime import datetime
from datetime import timedelta
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from bson import ObjectId
from pdf_export import generar_tex_nota_latex, generar_pdf_nota_latex
import streamlit as st
import pandas as pd
from streamlit_ace import st_ace

def _find_one_by_id(coll, id_value):
    """Find a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    # Normalize to string for parsing
    s = str(id_value)
    # First try ObjectId
    try:
        oid = ObjectId(s)
        doc = coll.find_one({"_id": oid})
        if doc is not None:
            return doc
    except Exception:
        pass
    # Fallback: string _id
    try:
        return coll.find_one({"_id": s})
    except Exception:
        return None


def _update_one_by_id(coll, id_value, update_doc):
    """Update a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    s = str(id_value)
    try:
        oid = ObjectId(s)
        res = coll.update_one({"_id": oid}, update_doc)
        if getattr(res, "matched_count", 0) > 0:
            return res
    except Exception:
        pass
    try:
        return coll.update_one({"_id": s}, update_doc)
    except Exception:
        return None



def _parse_tags_csv(s: str) -> List[str]:
    """Parse comma-separated tags into a clean list."""
    if not s:
        return []
    parts = [p.strip() for p in s.split(",")]
    return [p for p in parts if p]


def _note_label(doc: Dict[str, Any]) -> str:
    d = doc.get("date") or ""
    title = doc.get("title") or "(sin t√≠tulo)"
    proj = doc.get("project") or "‚Äî"
    ctx = doc.get("context") or "‚Äî"
    return f"{d} ‚Äî {title}  ¬∑  {proj} / {ctx}"


def _get_editor_keys(prefix: str) -> Dict[str, str]:
    return {
        "text": f"{prefix}_latex_text",
        "rev": f"{prefix}_latex_editor_rev",
        "insert": f"{prefix}_latex_insert",
        "do_insert": f"{prefix}_insert_latex",
        "loaded_id": f"{prefix}_loaded_id",
    }


def _ensure_editor_state(prefix: str, initial_text: str = "") -> None:
    keys = _get_editor_keys(prefix)
    if keys["text"] not in st.session_state:
        st.session_state[keys["text"]] = initial_text or ""
    if keys["rev"] not in st.session_state:
        st.session_state[keys["rev"]] = 0
    if keys["insert"] not in st.session_state:
        st.session_state[keys["insert"]] = ""
    if keys["do_insert"] not in st.session_state:
        st.session_state[keys["do_insert"]] = False
    if keys["loaded_id"] not in st.session_state:
        st.session_state[keys["loaded_id"]] = ""


def _queue_insert(prefix: str, snippet: str) -> None:
    keys = _get_editor_keys(prefix)
    st.session_state[keys["insert"]] = snippet
    st.session_state[keys["do_insert"]] = True


def _handle_pending_insert(prefix: str) -> None:
    keys = _get_editor_keys(prefix)
    if st.session_state.get(keys["do_insert"]) and st.session_state.get(keys["insert"]):
        current_text = st.session_state.get(keys["text"], "") or ""
        to_insert = st.session_state[keys["insert"]]

        if current_text and not current_text.endswith("\n"):
            current_text += "\n"

        st.session_state[keys["text"]] = current_text + to_insert + "\n"
        st.session_state[keys["do_insert"]] = False
        st.session_state[keys["insert"]] = ""
        st.session_state[keys["rev"]] += 1
        st.rerun()


def _render_latex_toolbar(prefix: str) -> None:
    """Toolbar: same spirit as 'A√±adir Concepto' + semantic diary blocks."""
    st.write("**üîß Herramientas LaTeX:**")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        if st.button("üìù Definici√≥n", key=f"{prefix}_btn_def"):
            _queue_insert(prefix, "\\begin{definition}\n% ...\n\\end{definition}\n")
        if st.button("üìã Teorema", key=f"{prefix}_btn_theorem"):
            _queue_insert(prefix, "\\begin{theorem}{% ...}\n% ...\n\\end{theorem}\n")
        if st.button("üìå Lema", key=f"{prefix}_btn_lemma"):
            _queue_insert(prefix, "\\begin{lemma}\n% ...\n\\end{lemma}\n")
        if st.button("üìå Proposici√≥n", key=f"{prefix}_btn_prop"):
            _queue_insert(prefix, "\\begin{proposition}\n% ...\n\\end{proposition}\n")
        if st.button("üìã Corolario", key=f"{prefix}_btn_cor"):
            _queue_insert(prefix, "\\begin{corollary}\n% ...\n\\end{corollary}\n")
        if st.button("üìñ Prueba", key=f"{prefix}_btn_proof"):
            _queue_insert(prefix, "\\begin{proof}\n% ...\n\\end{proof}\n")

    with col2:
        if st.button("üß™ Ejemplo", key=f"{prefix}_btn_ex"):
            _queue_insert(prefix, "\\begin{example}\n% ...\n\\end{example}\n")
        if st.button("üóíÔ∏è Nota / Remark", key=f"{prefix}_btn_remark"):
            _queue_insert(prefix, "\\begin{remark}\n% ...\n\\end{remark}\n")
        if st.button("üî¢ Ecuaci√≥n", key=f"{prefix}_btn_eq"):
            _queue_insert(prefix, "\\begin{equation}\n% ...\n\\end{equation}\n")
        if st.button("üî¢ Align", key=f"{prefix}_btn_align"):
            _queue_insert(prefix, "\\begin{align}\n% ...\n\\end{align}\n")
        if st.button("üî¢ Matrix", key=f"{prefix}_btn_matrix"):
            _queue_insert(prefix, "\\begin{pmatrix}\na & b \\\\\nc & d\n\\end{pmatrix}\n")
        if st.button("üî¢ Cases", key=f"{prefix}_btn_cases"):
            _queue_insert(prefix, "\\begin{cases}\n% ...\n\\end{cases}\n")

    with col3:
        if st.button("‚Ä¢ Itemize", key=f"{prefix}_btn_itemize"):
            _queue_insert(prefix, "\\begin{itemize}\n  \\item ...\n\\end{itemize}\n")
        if st.button("1) Enumerate", key=f"{prefix}_btn_enum"):
            _queue_insert(prefix, "\\begin{enumerate}\n  \\item ...\n\\end{enumerate}\n")
        if st.button("‚â° Description", key=f"{prefix}_btn_desc"):
            _queue_insert(prefix, "\\begin{description}\n  \\item[\√çtem] ...\n\\end{description}\n")
        if st.button("üíª C√≥digo (lstlisting)", key=f"{prefix}_btn_code"):
            _queue_insert(prefix, "\\begin{lstlisting}\n# ...\n\\end{lstlisting}\n")
        if st.button("üìÅ DirTree", key=f"{prefix}_btn_dirtree"):
            _queue_insert(prefix, "\\begin{dirtree}\n.1 /ruta.\n.2 archivo.txt.\n\\end{dirtree}\n")

    with col4:
        # S√≠mbolos (m√≠nimo viable)
        sym_cols = st.columns(2)
        with sym_cols[0]:
            if st.button("‚àë", key=f"{prefix}_sym_sum"):
                _queue_insert(prefix, "\\sum_{i=1}^{n}")
            if st.button("‚à´", key=f"{prefix}_sym_int"):
                _queue_insert(prefix, "\\int_{a}^{b}")
            if st.button("‚àà", key=f"{prefix}_sym_in"):
                _queue_insert(prefix, "\\in")
            if st.button("‚àÄ", key=f"{prefix}_sym_forall"):
                _queue_insert(prefix, "\\forall")
            if st.button("‚Ñù", key=f"{prefix}_sym_R"):
                _queue_insert(prefix, "\\mathbb{R}")
        with sym_cols[1]:
            if st.button("‚àÉ", key=f"{prefix}_sym_exists"):
                _queue_insert(prefix, "\\exists")
            if st.button("‚Üí", key=f"{prefix}_sym_to"):
                _queue_insert(prefix, "\\rightarrow")
            if st.button("‚àû", key=f"{prefix}_sym_inf"):
                _queue_insert(prefix, "\\infty")
            if st.button("Œµ", key=f"{prefix}_sym_eps"):
                _queue_insert(prefix, "\\varepsilon")
            if st.button("Œ¥", key=f"{prefix}_sym_delta"):
                _queue_insert(prefix, "\\delta")

    st.write("**üß© Bloques sem√°nticos del cuaderno:**")
    b1, b2, b3, b4, b5 = st.columns(5)
    semantic = [
        ("context", b1),
        ("reading", b1),
        ("exploration", b2),
        ("hypothesis", b2),
        ("connections", b3),
        ("reflection", b3),
        ("decision", b4),
        ("openquestions", b4),
        ("technical", b5),
        ("nextsteps", b5),
    ]
    for name, col in semantic:
        with col:
            if st.button(name, key=f"{prefix}_sem_{name}"):
                _queue_insert(prefix, f"\\begin{{{name}}}\n...\n\\end{{{name}}}\n")


def _render_latex_ace_editor(prefix: str, initial_text: str, height: int = 320) -> str:
    """Ace editor with deterministic insertion mechanism (stable on reruns)."""
    _ensure_editor_state(prefix, initial_text=initial_text)
    _handle_pending_insert(prefix)

    keys = _get_editor_keys(prefix)
    value = st_ace(
        value=st.session_state[keys["text"]],
        language="latex",
        theme="monokai",
        font_size=16,
        tab_size=2,
        height=height,
        wrap=True,
        show_gutter=True,
        auto_update=True,
        key=f"{prefix}_latex_editor_{st.session_state[keys['rev']]}",
    )
    st.session_state[keys["text"]] = value or ""
    return st.session_state[keys["text"]]
def render_cuaderno(db, _cuaderno_is_installed: Callable[[], bool]) -> None:
    """
    Renderiza la p√°gina üß™ Cuaderno (Experimental).

    Args:
        db: handle de MongoDB (pymongo database)
        _cuaderno_is_installed: funci√≥n que valida si el modo cuaderno est√° instalado
    """
    st.title("üß™ Cuaderno (Experimental)")

    if db is None:
        st.error("‚ùå No database connection. Please select a database in the sidebar.")
        st.stop()

    if not _cuaderno_is_installed(db):
        st.warning(
        "El modo cuaderno no est√° instalado en esta base de datos. "
        "Ejecuta: `make cuaderno-install`"
    )
    else:
        mongo_db = getattr(db, "db", None)
        if mongo_db is None:
            st.error("‚ùå No se pudo acceder al objeto pymongo database (db.db).")
            st.stop()

    c_worklog = mongo_db["worklog_entries"].count_documents({})
    c_backlog = mongo_db["backlog_items"].count_documents({})
    c_weekly = mongo_db["weekly_reviews"].count_documents({})
    c_deliv = mongo_db["deliverables"].count_documents({})
    c_notes = mongo_db["latex_notes"].count_documents({})

    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("Worklog", c_worklog)
    col2.metric("Backlog", c_backlog)
    col3.metric("Weekly", c_weekly)
    col4.metric("Deliverables", c_deliv)
    col5.metric("Diario", c_notes)

    st.info(
        "Este m√≥dulo es experimental. En los siguientes MVPs habilitaremos: "
        "Worklog ‚Üí Backlog ‚Üí Weekly Review ‚Üí Deliverables ‚Üí Kanban."
    )
    with st.expander("Instalaci√≥n / Estado", expanded=False):
        st.code("make cuaderno-install\nmake cuaderno-status", language="bash")

    tabs = st.tabs(["Worklog", "Backlog", "Weekly Review", "Deliverables", "Kanban", "Diario"])

    with tabs[0]:
        st.subheader("üïí Worklog")

        with st.form("worklog_form", clear_on_submit=False):
            col_a, col_b = st.columns(2)

            with col_a:
                w_date = st.date_input("Date", value=datetime.today())
                w_block = st.selectbox("Block", ["AM", "PM", "Noche"])
                w_hours = st.number_input("Hours", min_value=0.0, value=0.0, step=0.25)
                w_status = st.selectbox(
                    "Status",
                    ["Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                )

            with col_b:
                w_project = st.text_input("Project")
                w_module = st.text_input("Module (optional)")
                w_task = st.text_input("Task")
                w_next_step = st.text_input("Next step (optional)")

            w_desc = st.text_area("Descripci√≥n / Evidencia (optional)")
            w_evidence_url = st.text_input("Evidence URL / path (optional)")
            w_tags_csv = st.text_input("Tags (comma-separated)")

            submitted = st.form_submit_button("Add Worklog Entry")

        if submitted:
            if not w_project.strip() or not w_task.strip():
                st.error("Project y Task son obligatorios.")
            else:
                date_str = w_date.strftime("%Y-%m-%d")
                iso = datetime.strptime(date_str, "%Y-%m-%d").isocalendar()
                iso_year = int(getattr(iso, "year", iso[0]))
                iso_week = int(getattr(iso, "week", iso[1]))

                tags = [t.strip() for t in w_tags_csv.split(",") if t.strip()]
                now = datetime.utcnow()

                doc = {
                    "date": date_str,
                    "block": w_block,
                    "start_time": None,
                    "end_time": None,
                    "hours": float(w_hours),
                    "project": w_project.strip(),
                    "module": w_module.strip() or None,
                    "task": w_task.strip(),
                    "description_evidence": w_desc.strip() or None,
                    "status": w_status,
                    "deliverable_id": None,
                    "evidence_url": w_evidence_url.strip() or None,
                    "next_step": w_next_step.strip() or None,
                    "tags": tags,
                    "iso_year": iso_year,
                    "iso_week": iso_week,
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    mongo_db["worklog_entries"].insert_one(doc)
                    st.success("‚úÖ Worklog entry guardada.")
                except Exception as e:
                    st.error(f"‚ùå Error guardando worklog: {e}")

        st.markdown("### Recientes (√∫ltimas 20 entradas)")
        try:
            rows = list(
                mongo_db["worklog_entries"]
                .find({}, {"_id": 0})
                .sort([("date", -1), ("created_at", -1)])
                .limit(20)
            )
            if not rows:
                st.info("A√∫n no hay entradas en worklog.")
            else:
                df = pd.DataFrame(rows)
                st.dataframe(df, width='stretch')
        except Exception as e:
            st.error(f"‚ùå Error cargando worklog: {e}")
    with tabs[1]:
        st.subheader("üìã Backlog (V4)")

        col_f1, col_f2, col_f3 = st.columns([2, 1, 1])
        with col_f1:
            flt_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted([p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]),
                index=0,
                key="backlog_filter_project",
            )
        with col_f2:
            flt_status = st.selectbox(
                "Status (filter)",
                options=["(all)", "Todo", "Doing", "Done", "Blocked", "Canceled"],
                index=0,
                key="backlog_filter_status",
            )
        with col_f3:
            flt_priority = st.selectbox(
                "Priority (filter)",
                options=["(all)", "Alta", "Media", "Baja"],
                index=0,
                key="backlog_filter_priority",
            )

        query = {}
        if flt_project != "(all)":
            query["project"] = flt_project
        if flt_status != "(all)":
            query["status"] = flt_status
        if flt_priority != "(all)":
            query["priority"] = flt_priority

        st.markdown("### ‚ûï Crear backlog item")

        # Nota: usamos form + submit button expl√≠cito (sin submits impl√≠citos por Enter).
        with st.form("backlog_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                b_project = st.text_input("Project", value=flt_project if flt_project != "(all)" else "")
                b_module = st.text_input("Module (optional)", value="")
                b_owner = st.text_input("Owner", value=os.getenv("USER", "") or "user")
                b_priority = st.selectbox("Priority", ["Alta", "Media", "Baja"], index=1)
                b_status = st.selectbox("Status", ["Todo", "Doing", "Done", "Blocked", "Canceled"], index=0)

            with c2:
                b_task = st.text_input("Task (short)", value="")
                b_description = st.text_area("Description (optional)", value="", height=120)
                b_estimate = st.number_input("Estimate hours (optional)", min_value=0.0, value=0.0, step=0.25)
                use_target = st.checkbox("Set target date", value=False)
                b_target_date = st.date_input("Target date", value=datetime.today(), disabled=not use_target)

            b_tags_csv = st.text_input("Tags (comma-separated)", value="")
            create_btn = st.form_submit_button("Guardar backlog item")

            if create_btn:
                b_project_s = (b_project or "").strip()
                b_task_s = (b_task or "").strip()
                b_owner_s = (b_owner or "").strip()

                if not b_project_s or not b_task_s or not b_owner_s:
                    st.error("‚ùå Campos requeridos: Project, Task, Owner.")
                else:
                    now = datetime.utcnow()
                    doc = {
                        "project": b_project_s,
                        "module": (b_module or "").strip() or None,
                        "task": b_task_s,
                        "description": (b_description or "").strip() or None,
                        "priority": b_priority,
                        "status": b_status,
                        "estimate_hours": float(b_estimate) if b_estimate and float(b_estimate) > 0 else None,
                        "owner": b_owner_s,
                        "target_date": b_target_date.strftime("%Y-%m-%d") if use_target else None,
                        "tags": [t.strip() for t in (b_tags_csv or "").split(",") if t.strip()],
                        "created_at": now,
                        "updated_at": now,
                    }

                    try:
                        mongo_db["backlog_items"].insert_one(doc)
                        st.success("‚úÖ Backlog item guardado.")
                    except Exception as e:
                        st.error(f"‚ùå Error guardando backlog item: {e}")

        st.markdown("---")
        st.markdown("### üìå Items (recientes)")

        try:
            items = list(
                mongo_db["backlog_items"]
                .find(query)
                .sort("updated_at", -1)
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog: {e}")
            items = []

        if not items:
            st.info("No hay backlog items para este filtro.")
        else:
            rows = []
            for it in items:
                rows.append(
                    {
                        "_id": str(it.get("_id")),
                        "project": it.get("project", ""),
                        "module": it.get("module", ""),
                        "task": it.get("task", ""),
                        "priority": it.get("priority", ""),
                        "status": it.get("status", ""),
                        "owner": it.get("owner", ""),
                        "target_date": it.get("target_date", ""),
                        "updated_at": it.get("updated_at", ""),
                    }
                )

            df = pd.DataFrame(rows)
            st.dataframe(df, width='stretch', hide_index=True)

            st.markdown("### ‚úèÔ∏è Actualizar item")
            options = [
                (r["_id"], f"[{r['status']}] {r['project']} ‚Äî {r['task']}")
                for r in rows
            ]
            selected_id = st.selectbox(
                "Selecciona un item",
                options=[o[0] for o in options],
                format_func=lambda x: dict(options).get(x, x),
                key="backlog_select_item",
            )

            # Obtener el documento actual
            current = None
            try:
                current = _find_one_by_id(mongo_db["backlog_items"], selected_id)
            except Exception:
                current = None

            if current is None:
                st.warning("No se pudo cargar el item seleccionado.")
            else:
                u1, u2, u3 = st.columns([1, 1, 1])
                with u1:
                    new_status = st.selectbox(
                        "New status",
                        ["Todo", "Doing", "Done", "Blocked", "Canceled"],
                        index=["Todo", "Doing", "Done", "Blocked", "Canceled"].index(current.get("status", "Todo"))
                        if current.get("status") in ["Todo", "Doing", "Done", "Blocked", "Canceled"] else 0,
                        key="backlog_update_status",
                    )
                with u2:
                    new_priority = st.selectbox(
                        "New priority",
                        ["Alta", "Media", "Baja"],
                        index=["Alta", "Media", "Baja"].index(current.get("priority", "Media"))
                        if current.get("priority") in ["Alta", "Media", "Baja"] else 1,
                        key="backlog_update_priority",
                    )
                with u3:
                    new_owner = st.text_input(
                        "Owner",
                        value=current.get("owner", ""),
                        key="backlog_update_owner",
                    )

                upd_task = st.text_input("Task", value=current.get("task", ""), key="backlog_update_task")
                upd_desc = st.text_area(
                    "Description",
                    value=current.get("description") or "",
                    height=120,
                    key="backlog_update_desc",
                )

                u_tags = st.text_input(
                    "Tags (comma-separated)",
                    value=", ".join(current.get("tags", []) or []),
                    key="backlog_update_tags",
                )

                save_update = st.button("Guardar cambios", key="backlog_save_changes")
                if save_update:
                    try:
                        mongo_db["backlog_items"].update_one(
                            {"_id": current["_id"]},
                            {
                                "$set": {
                                    "status": new_status,
                                    "priority": new_priority,
                                    "owner": (new_owner or "").strip() or "user",
                                    "task": (upd_task or "").strip(),
                                    "description": (upd_desc or "").strip() or None,
                                    "tags": [t.strip() for t in (u_tags or "").split(",") if t.strip()],
                                    "updated_at": datetime.utcnow(),
                                }
                            },
                        )
                        st.success("‚úÖ Cambios guardados.")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Error actualizando backlog item: {e}")

    with tabs[2]:
        st.subheader("üìÖ Weekly Review (V5)")

        weekly_col = mongo_db["weekly_reviews"]

        today = date.today()
        iso_now = today.isocalendar()
        default_iso_year = int(iso_now.year)
        default_iso_week = int(iso_now.week)

        c1, c2 = st.columns(2)
        with c1:
            iso_year = st.number_input(
                "ISO Year",
                min_value=2000,
                max_value=2100,
                value=default_iso_year,
                step=1,
                key="weekly_iso_year",
            )
        with c2:
            iso_week = st.number_input(
                "ISO Week",
                min_value=1,
                max_value=53,
                value=default_iso_week,
                step=1,
                key="weekly_iso_week",
            )

        weekly_doc = None
        try:
            weekly_doc = weekly_col.find_one({"iso_year": int(iso_year), "iso_week": int(iso_week)})
        except Exception as e:
            st.error(f"‚ùå Error leyendo weekly review: {e}")

        def _join_lines(arr):
            if not arr:
                return ""
            if isinstance(arr, str):
                return arr
            return "\n".join([str(x) for x in arr if str(x).strip()])

        weekly_objectives_txt = st.text_area(
            "Objetivos de la semana (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("weekly_objectives")),
            height=120,
            placeholder="- Terminar MVP V4\n- Revisar paper X\n- Debug de microservicio Y",
            key="weekly_objectives_txt",
        )
        wins_txt = st.text_area(
            "Wins (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("wins")),
            height=120,
            placeholder="- Se aplic√≥ patch sin conflictos\n- Se resolvi√≥ bug de concurrencia",
            key="weekly_wins_txt",
        )
        blocks_risks_txt = st.text_area(
            "Bloqueos / riesgos (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("blocks_risks")),
            height=120,
            placeholder="- Falta contexto de archivo real\n- Riesgo de romper export a Quarto",
            key="weekly_blocks_risks_txt",
        )
        plan_next_week_txt = st.text_area(
            "Plan pr√≥xima semana (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("plan_next_week")),
            height=120,
            placeholder="- Implementar V5 completo\n- Documentar decisiones\n- Preparar clase",
            key="weekly_plan_next_week_txt",
        )

        def _split_lines(txt: str):
            return [ln.strip() for ln in (txt or "").splitlines() if ln.strip()]

        # Agregados autom√°ticos (best-effort)
        real_hours = None
        try:
            pipe = [
                {"$match": {"iso_year": int(iso_year), "iso_week": int(iso_week)}},
                {"$group": {"_id": None, "h": {"$sum": "$hours"}}},
            ]
            agg = list(mongo_db["worklog_entries"].aggregate(pipe))
            real_hours = float(agg[0]["h"]) if agg else 0.0
        except Exception:
            real_hours = None

        tasks_completed_count = None
        try:
            week_start = date.fromisocalendar(int(iso_year), int(iso_week), 1)
            week_end = week_start + timedelta(days=7)  # exclusivo
            tasks_completed_count = int(
                mongo_db["backlog_items"].count_documents(
                    {
                        "status": "Done",
                        "updated_at": {
                            "$gte": datetime(week_start.year, week_start.month, week_start.day),
                            "$lt": datetime(week_end.year, week_end.month, week_end.day),
                        },
                    }
                )
            )
        except Exception:
            tasks_completed_count = None

        m1, m2 = st.columns(2)
        with m1:
            st.metric(
                "Horas reales (worklog)",
                f"{real_hours:.2f}" if isinstance(real_hours, (int, float)) else "N/A",
            )
        with m2:
            st.metric(
                "Tareas Done (backlog)",
                tasks_completed_count if tasks_completed_count is not None else "N/A",
            )

        st.divider()

        if st.button("Guardar Weekly Review", key="weekly_save_btn"):
            now = datetime.utcnow()
            doc = {
                "iso_year": int(iso_year),
                "iso_week": int(iso_week),
                "weekly_objectives": _split_lines(weekly_objectives_txt),
                "wins": _split_lines(wins_txt),
                "blocks_risks": _split_lines(blocks_risks_txt),
                "plan_next_week": _split_lines(plan_next_week_txt),
                "agg_real_hours": real_hours if isinstance(real_hours, (int, float)) else None,
                "agg_tasks_done": tasks_completed_count,
                "updated_at": now,
            }

            try:
                weekly_col.update_one(
                    {"iso_year": int(iso_year), "iso_week": int(iso_week)},
                    {"$set": doc, "$setOnInsert": {"created_at": now}},
                    upsert=True,
                )
                st.success("‚úÖ Weekly Review guardada.")
                st.rerun()
            except Exception as e:
                st.error(f"‚ùå Error guardando Weekly Review: {e}")

    with tabs[3]:
        st.subheader("üì¶ Deliverables (V6)")

        deliverables_col = mongo_db["deliverables"]

        st.markdown("### ‚ûï Registrar entregable")

        with st.form("deliverables_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                d_date = st.date_input("Fecha", value=date.today())
                d_project = st.text_input("Proyecto")
                d_type = st.selectbox(
                    "Tipo",
                    ["reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                    index=0,
                    )
                d_deliverable = st.text_input("Deliverable (nombre)")

            with c2:
                d_path = st.text_input("Ruta / URL")
                d_commit = st.text_input("Commit ref (opcional)")
                d_tags_csv = st.text_input("Tags (comma-separated)")

            d_notes = st.text_area("Notas (opcional)", height=120)
            save_deliv = st.form_submit_button("Guardar entregable")

        if save_deliv:
            if not d_project.strip() or not d_deliverable.strip() or not d_path.strip():
                st.error("‚ùå Campos requeridos: Proyecto, Deliverable y Ruta / URL.")
            else:
                now = datetime.utcnow()
                doc = {
                    "date": d_date.strftime("%Y-%m-%d"),
                    "project": d_project.strip(),
                    "deliverable": d_deliverable.strip(),
                    "type": d_type,
                    "url_or_path": d_path.strip(),
                    "notes": d_notes.strip() or None,
                    "linked_worklog_ids": [],
                    "linked_note_ids": [],
                    "commit_ref": d_commit.strip() or None,
                    "linked_commits": [d_commit.strip()] if d_commit.strip() else [],
                    "tags": [t.strip() for t in d_tags_csv.split(",") if t.strip()],
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    deliverables_col.insert_one(doc)
                    st.success("‚úÖ Deliverable registrado.")
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando deliverable: {e}")

        st.divider()
        st.markdown("### üìÑ Entregables recientes")

        f1, f2, f3 = st.columns([2, 1, 1])
        with f1:
            flt_project = st.text_input("Project (filter)", value="")
        with f2:
            flt_type = st.selectbox(
                "Type (filter)",
                options=["(all)", "reporte", "codigo", "dataset", "presentacion", "evidencia", "otro"],
                index=0,
            )
        with f3:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=50, step=5)

        query = {}
        if flt_project.strip():
            query["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_type != "(all)":
            query["type"] = flt_type

        try:
            rows = list(
                deliverables_col.find(query, {"_id": 0})
                .sort([("date", -1), ("created_at", -1)])
                .limit(int(limit))
            )
            if not rows:
                st.info("No hay entregables para este filtro.")
            else:
                df = pd.DataFrame(rows)
                st.dataframe(df, width='stretch')
        except Exception as e:
            st.error(f"‚ùå Error cargando deliverables: {e}")


    with tabs[4]:
        st.subheader("üß± Kanban (V7 ‚Äî m√≠nimo)")
        st.caption("Vista m√≠nima del backlog por columnas. Cambio de estado v√≠a selectbox (sin drag & drop).")

        kf1, kf2 = st.columns([2, 1])
        with kf1:
            kb_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted(
                    [p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]
                ),
                index=0,
                key="kanban_filter_project",
            )
        with kf2:
            if st.button("üîÑ Refrescar", key="kanban_refresh"):
                st.rerun()

        k_query = {}
        if kb_project != "(all)":
            k_query["project"] = kb_project

        try:
            k_items = list(
                mongo_db["backlog_items"]
                .find(k_query)
                .sort("updated_at", -1)
                .limit(400)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog (kanban): {e}")
            k_items = []

        statuses = ["Todo", "Doing", "Blocked", "Done"]
        grouped = {s: [] for s in statuses}
        for it in k_items:
            s = it.get("status", "Todo")
            if s not in grouped:
                # Ignora estados fuera del Kanban m√≠nimo (p.ej. Canceled)
                continue
            grouped[s].append(it)

        col_todo, col_doing, col_blocked, col_done = st.columns(4)
        cols = {
            "Todo": col_todo,
            "Doing": col_doing,
            "Blocked": col_blocked,
            "Done": col_done,
        }

        for s in statuses:
            with cols[s]:
                st.markdown(f"#### {s} ({len(grouped[s])})")

                if not grouped[s]:
                    st.info("‚Äî")
                    continue

                for it in grouped[s][:50]:
                    _id_str = str(it.get("_id"))
                    title = f"{it.get('project','')} ‚Äî {it.get('task','')}"
                    with st.expander(title, expanded=False):
                        meta_left, meta_right = st.columns([2, 1])
                        with meta_left:
                            st.write(f"**Module:** {it.get('module') or '‚Äî'}")
                            st.write(f"**Priority:** {it.get('priority') or '‚Äî'}")
                            st.write(f"**Owner:** {it.get('owner') or '‚Äî'}")
                            if it.get("target_date"):
                                st.write(f"**Target date:** {it.get('target_date')}")
                        with meta_right:
                            st.write(f"**Updated:** {it.get('updated_at') or '‚Äî'}")
                            st.write(f"**Id:** `{_id_str}`")

                        new_status = st.selectbox(
                            "Status",
                            options=statuses,
                            index=statuses.index(s),
                            key=f"kanban_status_{_id_str}",
                        )

                        apply_btn = st.button(
                            "Aplicar cambio",
                            key=f"kanban_apply_{_id_str}",
                            disabled=(new_status == s),
                        )

                        if apply_btn and new_status != s:
                            now = datetime.utcnow()
                            res = _update_one_by_id(
                                mongo_db["backlog_items"],
                                _id_str,
                                {"$set": {"status": new_status, "updated_at": now}},
                            )
                            if res is not None and getattr(res, "matched_count", 0) > 0:
                                st.success("‚úÖ Estado actualizado.")
                                st.rerun()
                            else:
                                st.error("‚ùå No se pudo actualizar el estado (id no encontrado).")



    with tabs[5]:
        st.subheader("üìì Diario LaTeX (V8)")
        st.caption("Captura y consulta de notas largas en LaTeX. (Sin exportaci√≥n todav√≠a)")
        notes_col = mongo_db["latex_notes"]


        st.markdown("### ‚ûï Nueva nota")
        # --- Reset seguro del form "Nueva nota" (antes de instanciar widgets) ---
        if st.session_state.pop("diary_clear_new_form", False):
            for _k in ("diary_new_title", "diary_new_date", "diary_new_project", "diary_new_context", "diary_new_tags"):
                st.session_state.pop(_k, None)
            _keys = _get_editor_keys("diary_new")
            st.session_state.pop(_keys["text"], None)
            st.session_state[_keys["rev"]] = st.session_state.get(_keys["rev"], 0) + 1


        c1, c2 = st.columns([2, 1])
        with c1:
            n_title = st.text_input("T√≠tulo", key="diary_new_title")
        with c2:
            n_date = st.date_input("Fecha", value=date.today(), key="diary_new_date")
            n_project = st.text_input("Proyecto (opcional)", value="", key="diary_new_project")
            n_context = st.selectbox(
                "Contexto",
                options=["estudio", "debug", "lectura", "idea", "reflexion"],
                index=0,
                key="diary_new_context",
            )
            n_tags_raw = st.text_input("Tags (comma-separated)", value="", key="diary_new_tags")

        _render_latex_toolbar(prefix="diary_new")
        n_latex = _render_latex_ace_editor(prefix="diary_new", initial_text="", height=320)

        if st.button("Guardar nota", key="diary_new_save"):
            tags = _parse_tags_csv(n_tags_raw)
            if not (n_title or "").strip() or not (n_latex or "").strip():
                st.error("‚ö†Ô∏è T√≠tulo y contenido LaTeX son obligatorios.")
            else:
                doc = {
                    "title": n_title.strip(),
                    "date": n_date.strftime("%Y-%m-%d"),
                    "project": (n_project or "").strip(),
                    "context": n_context,
                    "tags": tags,
                    "latex_body": n_latex,
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow(),
                }
                try:
                    notes_col.insert_one(doc)
                    st.success("‚úÖ Nota guardada.")
                    # Limpieza m√≠nima
                    # Limpiar el formulario en el siguiente rerun (evita modificar session_state despu√©s de instanciar widgets)
                    st.session_state["diary_clear_new_form"] = True
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando nota: {e}")
                    st.error(f"‚ùå Error guardando nota: {e}")

        st.divider()
        st.markdown("### üîé Buscar notas")

        f1, f2, f3, f4 = st.columns([2, 1, 1, 1])
        with f1:
            flt_q = st.text_input("Texto (t√≠tulo o cuerpo)", value="")
        with f2:
            flt_project = st.text_input("Proyecto", value="")
        with f3:
            flt_context = st.selectbox(
            "Contexto",
            options=["(all)", "estudio", "debug", "lectura", "idea", "reflexion"],
            index=0,
        )
        with f4:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=30, step=5)

        q = {}
        if flt_project.strip():
            q["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_context != "(all)":
            q["context"] = flt_context
        if flt_q.strip():
            rx = {"$regex": re.escape(flt_q.strip()), "$options": "i"}
            q["$or"] = [{"title": rx}, {"latex_body": rx}]

        try:
            notes = list(
            notes_col.find(q)
            .sort([("date", -1), ("updated_at", -1)])
            .limit(int(limit))
        )
        except Exception as e:
            st.error(f"‚ùå Error cargando notas: {e}")
            notes = []

        if not notes:
            st.info("No hay notas para este filtro.")
        else:
            for n in notes:
                nid = str(n.get("_id"))
                title = n.get("title") or "(sin t√≠tulo)"
                d = n.get("date") or ""
                proj = n.get("project") or "‚Äî"
                ctx = n.get("context") or "‚Äî"
                tags = ", ".join(n.get("tags") or [])

                with st.expander(f"{d} ‚Äî {title}", expanded=False):
                    meta1, meta2 = st.columns([2, 1])
                    with meta1:
                        st.write(f"**Proyecto:** {proj}")
                        st.write(f"**Contexto:** {ctx}")
                        if tags:
                            st.write(f"**Tags:** {tags}")
                    with meta2:
                        st.write(f"**Id:** `{nid}`")
                        st.write(f"**Updated:** {n.get('updated_at') or '‚Äî'}")

                    st.code(n.get("latex_body") or "", language="latex")



        st.divider()
        st.markdown("### ‚úèÔ∏è Editar nota")

        if not notes:
            st.info("No hay notas cargadas para editar con este filtro.")
        else:
            opt_map: Dict[str, str] = {}
            opt_labels: List[str] = []
            for n in notes:
                _nid = str(n.get("_id"))
                label = _note_label(n)
                opt_labels.append(label)
                opt_map[label] = _nid

            selected_label = st.selectbox(
                "Selecciona una nota para editar",
                options=opt_labels,
                index=0,
                key="diary_edit_select",
            )
            nid = opt_map.get(selected_label)
            note_doc = _find_one_by_id(notes_col, nid) if nid else None

            if not note_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                # Cargar valores al cambiar de selecci√≥n
                edit_prefix = "diary_edit"
                keys = _get_editor_keys(edit_prefix)
                if st.session_state.get(keys["loaded_id"]) != str(note_doc.get("_id")):
                    st.session_state[keys["loaded_id"]] = str(note_doc.get("_id"))
                    st.session_state["diary_edit_title"] = note_doc.get("title") or ""
                    # date guardada como string YYYY-MM-DD
                    try:
                        st.session_state["diary_edit_date"] = datetime.strptime(note_doc.get("date") or "", "%Y-%m-%d").date()
                    except Exception:
                        st.session_state["diary_edit_date"] = date.today()
                    st.session_state["diary_edit_project"] = note_doc.get("project") or ""
                    st.session_state["diary_edit_context"] = note_doc.get("context") or "estudio"
                    st.session_state["diary_edit_tags"] = ", ".join(note_doc.get("tags") or [])
                    st.session_state[keys["text"]] = note_doc.get("latex_body") or ""
                    st.session_state[keys["rev"]] += 1

                e1, e2 = st.columns([2, 1])
                with e1:
                    e_title = st.text_input("T√≠tulo", key="diary_edit_title")
                with e2:
                    e_date = st.date_input("Fecha", key="diary_edit_date")
                    e_project = st.text_input("Proyecto (opcional)", key="diary_edit_project")
                    e_context = st.selectbox(
                        "Contexto",
                        options=["estudio", "debug", "lectura", "idea", "reflexion"],
                        index=["estudio", "debug", "lectura", "idea", "reflexion"].index(st.session_state.get("diary_edit_context", "estudio"))
                        if st.session_state.get("diary_edit_context", "estudio") in ["estudio", "debug", "lectura", "idea", "reflexion"]
                        else 0,
                        key="diary_edit_context",
                    )
                    e_tags_raw = st.text_input("Tags (comma-separated)", key="diary_edit_tags")

                _render_latex_toolbar(prefix=edit_prefix)
                e_latex = _render_latex_ace_editor(prefix=edit_prefix, initial_text=note_doc.get("latex_body") or "", height=420)

                if st.button("Guardar cambios", key="diary_edit_save"):
                    if not (e_title or "").strip() or not (e_latex or "").strip():
                        st.error("‚ö†Ô∏è T√≠tulo y contenido LaTeX son obligatorios.")
                    else:
                        tags = _parse_tags_csv(e_tags_raw)
                        upd = {
                            "title": e_title.strip(),
                            "date": e_date.strftime("%Y-%m-%d"),
                            "project": (e_project or "").strip(),
                            "context": e_context,
                            "tags": tags,
                            "latex_body": e_latex,
                            "updated_at": datetime.utcnow(),
                        }
                        try:
                            notes_col.update_one({"_id": ObjectId(nid)}, {"$set": upd})
                            st.success("‚úÖ Nota actualizada.")
                            st.rerun()
                        except Exception as e:
                            st.error(f"‚ùå Error actualizando nota: {e}")

        st.divider()
        st.markdown("### üóëÔ∏è Borrar nota")

        if not notes:
            st.info("No hay notas cargadas para borrar con este filtro.")
        else:
            del_opt_map: Dict[str, str] = {}
            del_opt_labels: List[str] = []
            for n in notes:
                _nid = str(n.get("_id"))
                label = _note_label(n)
                del_opt_labels.append(label)
                del_opt_map[label] = _nid

            del_selected = st.selectbox(
                "Selecciona una nota para borrar",
                options=del_opt_labels,
                index=0,
                key="diary_delete_select",
            )
            del_nid = del_opt_map.get(del_selected)
            del_doc = _find_one_by_id(notes_col, del_nid) if del_nid else None

            if not del_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                st.write(f"**T√≠tulo:** {del_doc.get('title') or '(sin t√≠tulo)'}")
                st.write(f"**Fecha:** {del_doc.get('date') or ''}")
                st.write(f"**Proyecto:** {del_doc.get('project') or '‚Äî'}")
                st.write(f"**Contexto:** {del_doc.get('context') or '‚Äî'}")
                preview = (del_doc.get("latex_body") or "")[:400]
                if preview:
                    st.code(preview, language="latex")

                confirm = st.checkbox("Estoy seguro", key="diary_delete_confirm")
                typed = st.text_input("Escribe BORRAR para confirmar", value="", key="diary_delete_typed")

                if st.button("Borrar definitivamente", key="diary_delete_btn"):
                    if not confirm or typed.strip().upper() != "BORRAR":
                        st.error("Confirmaci√≥n incompleta. Marca el checkbox y escribe BORRAR.")
                    else:
                        try:
                            notes_col.delete_one({"_id": ObjectId(del_nid)})
                            st.success("‚úÖ Nota borrada.")
                            st.rerun()
                        except Exception as e:
                            st.error(f"‚ùå Error borrando nota: {e}")
        st.markdown("#### üì§ Exportar")

        if not notes:
            st.info("Primero crea o filtra una nota para poder exportar.")
        else:
            # Selecci√≥n expl√≠cita de nota a exportar (evita variables fuera de scope)
            opt_labels = []
            opt_map = {}
            for n in notes:
                _nid = str(n.get("_id"))
                _d = n.get("date") or ""
                _t = n.get("title") or "(sin t√≠tulo)"
                label = f"{_d} ‚Äî {_t}"
                opt_labels.append(label)
                opt_map[label] = _nid

            selected_label = st.selectbox(
                "Selecciona una nota",
                options=opt_labels,
                index=0,
                key="latex_notes_export_select",
            )
            nid = opt_map.get(selected_label)
            note_doc = None
            if nid:
                note_doc = _find_one_by_id(notes_col, nid)

            if not note_doc:
                st.warning("No se pudo cargar la nota seleccionada.")
            else:
                e1, e2 = st.columns(2)

                with e1:
                    if st.button("Generar TEX", key=f"note_tex_gen_{nid}"):
                        st.session_state[f"note_tex_{nid}"] = generar_tex_nota_latex(note_doc)
                        st.success("‚úÖ TEX listo para descargar.")

                    tex_data = st.session_state.get(f"note_tex_{nid}")
                    if tex_data:
                        st.download_button(
                            "Descargar TEX",
                            data=tex_data,
                            file_name=f"latex_note_{nid}.tex",
                            mime="text/x-tex",
                            key=f"note_tex_dl_{nid}",
                        )

                with e2:
                    if st.button("Generar PDF", key=f"note_pdf_gen_{nid}"):
                        try:
                            pdf_path = generar_pdf_nota_latex(note_doc)
                            st.session_state[f"note_pdf_path_{nid}"] = pdf_path
                            st.success("‚úÖ PDF listo para descargar.")
                        except Exception as e:
                            st.error(f"‚ùå Error generando PDF: {e}")

                    pdf_path = st.session_state.get(f"note_pdf_path_{nid}")
                    if pdf_path and os.path.exists(pdf_path):
                        with open(pdf_path, "rb") as f:
                            st.download_button(
                                "Descargar PDF",
                                data=f.read(),
                                file_name=os.path.basename(pdf_path),
                                mime="application/pdf",
                                key=f"note_pdf_dl_{nid}",
                            )
