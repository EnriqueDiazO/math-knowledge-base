"""
Auto-generated by scripts/split_cuaderno_page.py
Source: editor/editor_streamlit.py
Generated at: 2026-01-21T01:25:18.076642Z
"""

from __future__ import annotations

import os
import re
from collections import Counter
from datetime import date
from datetime import datetime
from datetime import timedelta
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from bson import ObjectId

import streamlit as st
import pandas as pd

def _find_one_by_id(coll, id_value):
    """Find a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    # Normalize to string for parsing
    s = str(id_value)
    # First try ObjectId
    try:
        oid = ObjectId(s)
        doc = coll.find_one({"_id": oid})
        if doc is not None:
            return doc
    except Exception:
        pass
    # Fallback: string _id
    try:
        return coll.find_one({"_id": s})
    except Exception:
        return None


def _update_one_by_id(coll, id_value, update_doc):
    """Update a document by _id supporting both ObjectId and string ids."""
    if id_value is None:
        return None
    s = str(id_value)
    try:
        oid = ObjectId(s)
        res = coll.update_one({"_id": oid}, update_doc)
        if getattr(res, "matched_count", 0) > 0:
            return res
    except Exception:
        pass
    try:
        return coll.update_one({"_id": s}, update_doc)
    except Exception:
        return None


def render_cuaderno(db, _cuaderno_is_installed: Callable[[], bool]) -> None:
    """
    Renderiza la p√°gina üß™ Cuaderno (Experimental).

    Args:
        db: handle de MongoDB (pymongo database)
        _cuaderno_is_installed: funci√≥n que valida si el modo cuaderno est√° instalado
    """
    st.title("üß™ Cuaderno (Experimental)")

    if db is None:
        st.error("‚ùå No database connection. Please select a database in the sidebar.")
        st.stop()

    if not _cuaderno_is_installed(db):
        st.warning(
        "El modo cuaderno no est√° instalado en esta base de datos. "
        "Ejecuta: `make cuaderno-install`"
    )
    else:
        mongo_db = getattr(db, "db", None)
        if mongo_db is None:
            st.error("‚ùå No se pudo acceder al objeto pymongo database (db.db).")
            st.stop()

    c_worklog = mongo_db["worklog_entries"].count_documents({})
    c_backlog = mongo_db["backlog_items"].count_documents({})
    c_weekly = mongo_db["weekly_reviews"].count_documents({})
    c_deliv = mongo_db["deliverables"].count_documents({})
    c_notes = mongo_db["latex_notes"].count_documents({})

    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("Worklog", c_worklog)
    col2.metric("Backlog", c_backlog)
    col3.metric("Weekly", c_weekly)
    col4.metric("Deliverables", c_deliv)
    col5.metric("Diario", c_notes)

    st.info(
        "Este m√≥dulo es experimental. En los siguientes MVPs habilitaremos: "
        "Worklog ‚Üí Backlog ‚Üí Weekly Review ‚Üí Deliverables ‚Üí Kanban."
    )
    with st.expander("Instalaci√≥n / Estado", expanded=False):
        st.code("make cuaderno-install\nmake cuaderno-status", language="bash")

    tabs = st.tabs(["Worklog", "Backlog", "Weekly Review", "Deliverables", "Kanban", "Diario"])

    with tabs[0]:
        st.subheader("üïí Worklog")

        with st.form("worklog_form", clear_on_submit=False):
            col_a, col_b = st.columns(2)

            with col_a:
                w_date = st.date_input("Date", value=datetime.today())
                w_block = st.selectbox("Block", ["AM", "PM", "Noche"])
                w_hours = st.number_input("Hours", min_value=0.0, value=0.0, step=0.25)
                w_status = st.selectbox(
                    "Status",
                    ["Planificado", "En progreso", "Hecho", "Bloqueado", "Cancelado"],
                )

            with col_b:
                w_project = st.text_input("Project")
                w_module = st.text_input("Module (optional)")
                w_task = st.text_input("Task")
                w_next_step = st.text_input("Next step (optional)")

            w_desc = st.text_area("Descripci√≥n / Evidencia (optional)")
            w_evidence_url = st.text_input("Evidence URL / path (optional)")
            w_tags_csv = st.text_input("Tags (comma-separated)")

            submitted = st.form_submit_button("Add Worklog Entry")

        if submitted:
            if not w_project.strip() or not w_task.strip():
                st.error("Project y Task son obligatorios.")
            else:
                date_str = w_date.strftime("%Y-%m-%d")
                iso = datetime.strptime(date_str, "%Y-%m-%d").isocalendar()
                iso_year = int(getattr(iso, "year", iso[0]))
                iso_week = int(getattr(iso, "week", iso[1]))

                tags = [t.strip() for t in w_tags_csv.split(",") if t.strip()]
                now = datetime.utcnow()

                doc = {
                    "date": date_str,
                    "block": w_block,
                    "start_time": None,
                    "end_time": None,
                    "hours": float(w_hours),
                    "project": w_project.strip(),
                    "module": w_module.strip() or None,
                    "task": w_task.strip(),
                    "description_evidence": w_desc.strip() or None,
                    "status": w_status,
                    "deliverable_id": None,
                    "evidence_url": w_evidence_url.strip() or None,
                    "next_step": w_next_step.strip() or None,
                    "tags": tags,
                    "iso_year": iso_year,
                    "iso_week": iso_week,
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    mongo_db["worklog_entries"].insert_one(doc)
                    st.success("‚úÖ Worklog entry guardada.")
                except Exception as e:
                    st.error(f"‚ùå Error guardando worklog: {e}")

        st.markdown("### Recientes (√∫ltimas 20 entradas)")
        try:
            rows = list(
                mongo_db["worklog_entries"]
                .find({}, {"_id": 0})
                .sort([("date", -1), ("created_at", -1)])
                .limit(20)
            )
            if not rows:
                st.info("A√∫n no hay entradas en worklog.")
            else:
                df = pd.DataFrame(rows)
                st.dataframe(df, use_container_width=True)
        except Exception as e:
            st.error(f"‚ùå Error cargando worklog: {e}")
    with tabs[1]:
        st.subheader("üìã Backlog (V4)")

        col_f1, col_f2, col_f3 = st.columns([2, 1, 1])
        with col_f1:
            flt_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted([p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]),
                index=0,
                key="backlog_filter_project",
            )
        with col_f2:
            flt_status = st.selectbox(
                "Status (filter)",
                options=["(all)", "Todo", "Doing", "Done", "Blocked", "Canceled"],
                index=0,
                key="backlog_filter_status",
            )
        with col_f3:
            flt_priority = st.selectbox(
                "Priority (filter)",
                options=["(all)", "Alta", "Media", "Baja"],
                index=0,
                key="backlog_filter_priority",
            )

        query = {}
        if flt_project != "(all)":
            query["project"] = flt_project
        if flt_status != "(all)":
            query["status"] = flt_status
        if flt_priority != "(all)":
            query["priority"] = flt_priority

        st.markdown("### ‚ûï Crear backlog item")

        # Nota: usamos form + submit button expl√≠cito (sin submits impl√≠citos por Enter).
        with st.form("backlog_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                b_project = st.text_input("Project", value=flt_project if flt_project != "(all)" else "")
                b_module = st.text_input("Module (optional)", value="")
                b_owner = st.text_input("Owner", value=os.getenv("USER", "") or "user")
                b_priority = st.selectbox("Priority", ["Alta", "Media", "Baja"], index=1)
                b_status = st.selectbox("Status", ["Todo", "Doing", "Done", "Blocked", "Canceled"], index=0)

            with c2:
                b_task = st.text_input("Task (short)", value="")
                b_description = st.text_area("Description (optional)", value="", height=120)
                b_estimate = st.number_input("Estimate hours (optional)", min_value=0.0, value=0.0, step=0.25)
                use_target = st.checkbox("Set target date", value=False)
                b_target_date = st.date_input("Target date", value=datetime.today(), disabled=not use_target)

            b_tags_csv = st.text_input("Tags (comma-separated)", value="")
            create_btn = st.form_submit_button("Guardar backlog item")

            if create_btn:
                b_project_s = (b_project or "").strip()
                b_task_s = (b_task or "").strip()
                b_owner_s = (b_owner or "").strip()

                if not b_project_s or not b_task_s or not b_owner_s:
                    st.error("‚ùå Campos requeridos: Project, Task, Owner.")
                else:
                    now = datetime.utcnow()
                    doc = {
                        "project": b_project_s,
                        "module": (b_module or "").strip() or None,
                        "task": b_task_s,
                        "description": (b_description or "").strip() or None,
                        "priority": b_priority,
                        "status": b_status,
                        "estimate_hours": float(b_estimate) if b_estimate and float(b_estimate) > 0 else None,
                        "owner": b_owner_s,
                        "target_date": b_target_date.strftime("%Y-%m-%d") if use_target else None,
                        "tags": [t.strip() for t in (b_tags_csv or "").split(",") if t.strip()],
                        "created_at": now,
                        "updated_at": now,
                    }

                    try:
                        mongo_db["backlog_items"].insert_one(doc)
                        st.success("‚úÖ Backlog item guardado.")
                    except Exception as e:
                        st.error(f"‚ùå Error guardando backlog item: {e}")

        st.markdown("---")
        st.markdown("### üìå Items (recientes)")

        try:
            items = list(
                mongo_db["backlog_items"]
                .find(query)
                .sort("updated_at", -1)
                .limit(200)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog: {e}")
            items = []

        if not items:
            st.info("No hay backlog items para este filtro.")
        else:
            rows = []
            for it in items:
                rows.append(
                    {
                        "_id": str(it.get("_id")),
                        "project": it.get("project", ""),
                        "module": it.get("module", ""),
                        "task": it.get("task", ""),
                        "priority": it.get("priority", ""),
                        "status": it.get("status", ""),
                        "owner": it.get("owner", ""),
                        "target_date": it.get("target_date", ""),
                        "updated_at": it.get("updated_at", ""),
                    }
                )

            df = pd.DataFrame(rows)
            st.dataframe(df, use_container_width=True, hide_index=True)

            st.markdown("### ‚úèÔ∏è Actualizar item")
            options = [
                (r["_id"], f"[{r['status']}] {r['project']} ‚Äî {r['task']}")
                for r in rows
            ]
            selected_id = st.selectbox(
                "Selecciona un item",
                options=[o[0] for o in options],
                format_func=lambda x: dict(options).get(x, x),
                key="backlog_select_item",
            )

            # Obtener el documento actual
            current = None
            try:
                current = _find_one_by_id(mongo_db["backlog_items"], selected_id)
            except Exception:
                current = None

            if current is None:
                st.warning("No se pudo cargar el item seleccionado.")
            else:
                u1, u2, u3 = st.columns([1, 1, 1])
                with u1:
                    new_status = st.selectbox(
                        "New status",
                        ["Todo", "Doing", "Done", "Blocked", "Canceled"],
                        index=["Todo", "Doing", "Done", "Blocked", "Canceled"].index(current.get("status", "Todo"))
                        if current.get("status") in ["Todo", "Doing", "Done", "Blocked", "Canceled"] else 0,
                        key="backlog_update_status",
                    )
                with u2:
                    new_priority = st.selectbox(
                        "New priority",
                        ["Alta", "Media", "Baja"],
                        index=["Alta", "Media", "Baja"].index(current.get("priority", "Media"))
                        if current.get("priority") in ["Alta", "Media", "Baja"] else 1,
                        key="backlog_update_priority",
                    )
                with u3:
                    new_owner = st.text_input(
                        "Owner",
                        value=current.get("owner", ""),
                        key="backlog_update_owner",
                    )

                upd_task = st.text_input("Task", value=current.get("task", ""), key="backlog_update_task")
                upd_desc = st.text_area(
                    "Description",
                    value=current.get("description") or "",
                    height=120,
                    key="backlog_update_desc",
                )

                u_tags = st.text_input(
                    "Tags (comma-separated)",
                    value=", ".join(current.get("tags", []) or []),
                    key="backlog_update_tags",
                )

                save_update = st.button("Guardar cambios", key="backlog_save_changes")
                if save_update:
                    try:
                        mongo_db["backlog_items"].update_one(
                            {"_id": current["_id"]},
                            {
                                "$set": {
                                    "status": new_status,
                                    "priority": new_priority,
                                    "owner": (new_owner or "").strip() or "user",
                                    "task": (upd_task or "").strip(),
                                    "description": (upd_desc or "").strip() or None,
                                    "tags": [t.strip() for t in (u_tags or "").split(",") if t.strip()],
                                    "updated_at": datetime.utcnow(),
                                }
                            },
                        )
                        st.success("‚úÖ Cambios guardados.")
                        st.rerun()
                    except Exception as e:
                        st.error(f"‚ùå Error actualizando backlog item: {e}")

    with tabs[2]:
        st.subheader("üìÖ Weekly Review (V5)")

        weekly_col = mongo_db["weekly_reviews"]

        today = date.today()
        iso_now = today.isocalendar()
        default_iso_year = int(iso_now.year)
        default_iso_week = int(iso_now.week)

        c1, c2 = st.columns(2)
        with c1:
            iso_year = st.number_input(
                "ISO Year",
                min_value=2000,
                max_value=2100,
                value=default_iso_year,
                step=1,
                key="weekly_iso_year",
            )
        with c2:
            iso_week = st.number_input(
                "ISO Week",
                min_value=1,
                max_value=53,
                value=default_iso_week,
                step=1,
                key="weekly_iso_week",
            )

        weekly_doc = None
        try:
            weekly_doc = weekly_col.find_one({"iso_year": int(iso_year), "iso_week": int(iso_week)})
        except Exception as e:
            st.error(f"‚ùå Error leyendo weekly review: {e}")

        def _join_lines(arr):
            if not arr:
                return ""
            if isinstance(arr, str):
                return arr
            return "\n".join([str(x) for x in arr if str(x).strip()])

        weekly_objectives_txt = st.text_area(
            "Objetivos de la semana (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("weekly_objectives")),
            height=120,
            placeholder="- Terminar MVP V4\n- Revisar paper X\n- Debug de microservicio Y",
            key="weekly_objectives_txt",
        )
        wins_txt = st.text_area(
            "Wins (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("wins")),
            height=120,
            placeholder="- Se aplic√≥ patch sin conflictos\n- Se resolvi√≥ bug de concurrencia",
            key="weekly_wins_txt",
        )
        blocks_risks_txt = st.text_area(
            "Bloqueos / riesgos (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("blocks_risks")),
            height=120,
            placeholder="- Falta contexto de archivo real\n- Riesgo de romper export a Quarto",
            key="weekly_blocks_risks_txt",
        )
        plan_next_week_txt = st.text_area(
            "Plan pr√≥xima semana (1 por l√≠nea)",
            value=_join_lines((weekly_doc or {}).get("plan_next_week")),
            height=120,
            placeholder="- Implementar V5 completo\n- Documentar decisiones\n- Preparar clase",
            key="weekly_plan_next_week_txt",
        )

        def _split_lines(txt: str):
            return [ln.strip() for ln in (txt or "").splitlines() if ln.strip()]

        # Agregados autom√°ticos (best-effort)
        real_hours = None
        try:
            pipe = [
                {"$match": {"iso_year": int(iso_year), "iso_week": int(iso_week)}},
                {"$group": {"_id": None, "h": {"$sum": "$hours"}}},
            ]
            agg = list(mongo_db["worklog_entries"].aggregate(pipe))
            real_hours = float(agg[0]["h"]) if agg else 0.0
        except Exception:
            real_hours = None

        tasks_completed_count = None
        try:
            week_start = date.fromisocalendar(int(iso_year), int(iso_week), 1)
            week_end = week_start + timedelta(days=7)  # exclusivo
            tasks_completed_count = int(
                mongo_db["backlog_items"].count_documents(
                    {
                        "status": "Done",
                        "updated_at": {
                            "$gte": datetime(week_start.year, week_start.month, week_start.day),
                            "$lt": datetime(week_end.year, week_end.month, week_end.day),
                        },
                    }
                )
            )
        except Exception:
            tasks_completed_count = None

        m1, m2 = st.columns(2)
        with m1:
            st.metric(
                "Horas reales (worklog)",
                f"{real_hours:.2f}" if isinstance(real_hours, (int, float)) else "N/A",
            )
        with m2:
            st.metric(
                "Tareas Done (backlog)",
                tasks_completed_count if tasks_completed_count is not None else "N/A",
            )

        st.divider()

        if st.button("Guardar Weekly Review", key="weekly_save_btn"):
            now = datetime.utcnow()
            doc = {
                "iso_year": int(iso_year),
                "iso_week": int(iso_week),
                "weekly_objectives": _split_lines(weekly_objectives_txt),
                "wins": _split_lines(wins_txt),
                "blocks_risks": _split_lines(blocks_risks_txt),
                "plan_next_week": _split_lines(plan_next_week_txt),
                "agg_real_hours": real_hours if isinstance(real_hours, (int, float)) else None,
                "agg_tasks_done": tasks_completed_count,
                "updated_at": now,
            }

            try:
                weekly_col.update_one(
                    {"iso_year": int(iso_year), "iso_week": int(iso_week)},
                    {"$set": doc, "$setOnInsert": {"created_at": now}},
                    upsert=True,
                )
                st.success("‚úÖ Weekly Review guardada.")
                st.rerun()
            except Exception as e:
                st.error(f"‚ùå Error guardando Weekly Review: {e}")

    with tabs[3]:
        st.subheader("üì¶ Deliverables (V6)")

        deliverables_col = mongo_db["deliverables"]

        st.markdown("### ‚ûï Registrar entregable")

        with st.form("deliverables_create_form", clear_on_submit=False):
            c1, c2 = st.columns(2)

            with c1:
                d_date = st.date_input("Fecha", value=date.today())
                d_project = st.text_input("Proyecto")
                d_type = st.selectbox(
                    "Tipo",
                    ["report", "code", "dataset", "slides", "doc", "other"],
                    index=0,
                )

            with c2:
                d_path = st.text_input("Ruta / URL")
                d_commit = st.text_input("Commit ref (opcional)")
                d_tags_csv = st.text_input("Tags (comma-separated)")

            d_notes = st.text_area("Notas (opcional)", height=120)
            save_deliv = st.form_submit_button("Guardar entregable")

        if save_deliv:
            if not d_project.strip() or not d_path.strip():
                st.error("‚ùå Campos requeridos: Proyecto y Ruta / URL.")
            else:
                now = datetime.utcnow()
                doc = {
                    "date": d_date.strftime("%Y-%m-%d"),
                    "project": d_project.strip(),
                    "type": d_type,
                    "path_or_url": d_path.strip(),
                    "commit_ref": d_commit.strip() or None,
                    "notes": d_notes.strip() or None,
                    "tags": [t.strip() for t in d_tags_csv.split(",") if t.strip()],
                    "created_at": now,
                    "updated_at": now,
                }

                try:
                    deliverables_col.insert_one(doc)
                    st.success("‚úÖ Deliverable registrado.")
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando deliverable: {e}")

        st.divider()
        st.markdown("### üìÑ Entregables recientes")

        f1, f2, f3 = st.columns([2, 1, 1])
        with f1:
            flt_project = st.text_input("Project (filter)", value="")
        with f2:
            flt_type = st.selectbox(
                "Type (filter)",
                options=["(all)", "report", "code", "dataset", "slides", "doc", "other"],
                index=0,
            )
        with f3:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=50, step=5)

        query = {}
        if flt_project.strip():
            query["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_type != "(all)":
            query["type"] = flt_type

        try:
            rows = list(
                deliverables_col.find(query, {"_id": 0})
                .sort([("date", -1), ("created_at", -1)])
                .limit(int(limit))
            )
            if not rows:
                st.info("No hay entregables para este filtro.")
            else:
                df = pd.DataFrame(rows)
                st.dataframe(df, use_container_width=True)
        except Exception as e:
            st.error(f"‚ùå Error cargando deliverables: {e}")


    with tabs[4]:
        st.subheader("üß± Kanban (V7 ‚Äî m√≠nimo)")
        st.caption("Vista m√≠nima del backlog por columnas. Cambio de estado v√≠a selectbox (sin drag & drop).")

        kf1, kf2 = st.columns([2, 1])
        with kf1:
            kb_project = st.selectbox(
                "Project (filter)",
                options=["(all)"] + sorted(
                    [p for p in mongo_db["backlog_items"].distinct("project") if isinstance(p, str)]
                ),
                index=0,
                key="kanban_filter_project",
            )
        with kf2:
            if st.button("üîÑ Refrescar", key="kanban_refresh"):
                st.rerun()

        k_query = {}
        if kb_project != "(all)":
            k_query["project"] = kb_project

        try:
            k_items = list(
                mongo_db["backlog_items"]
                .find(k_query)
                .sort("updated_at", -1)
                .limit(400)
            )
        except Exception as e:
            st.error(f"‚ùå Error cargando backlog (kanban): {e}")
            k_items = []

        statuses = ["Todo", "Doing", "Blocked", "Done"]
        grouped = {s: [] for s in statuses}
        for it in k_items:
            s = it.get("status", "Todo")
            if s not in grouped:
                # Ignora estados fuera del Kanban m√≠nimo (p.ej. Canceled)
                continue
            grouped[s].append(it)

        col_todo, col_doing, col_blocked, col_done = st.columns(4)
        cols = {
            "Todo": col_todo,
            "Doing": col_doing,
            "Blocked": col_blocked,
            "Done": col_done,
        }

        for s in statuses:
            with cols[s]:
                st.markdown(f"#### {s} ({len(grouped[s])})")

                if not grouped[s]:
                    st.info("‚Äî")
                    continue

                for it in grouped[s][:50]:
                    _id_str = str(it.get("_id"))
                    title = f"{it.get('project','')} ‚Äî {it.get('task','')}"
                    with st.expander(title, expanded=False):
                        meta_left, meta_right = st.columns([2, 1])
                        with meta_left:
                            st.write(f"**Module:** {it.get('module') or '‚Äî'}")
                            st.write(f"**Priority:** {it.get('priority') or '‚Äî'}")
                            st.write(f"**Owner:** {it.get('owner') or '‚Äî'}")
                            if it.get("target_date"):
                                st.write(f"**Target date:** {it.get('target_date')}")
                        with meta_right:
                            st.write(f"**Updated:** {it.get('updated_at') or '‚Äî'}")
                            st.write(f"**Id:** `{_id_str}`")

                        new_status = st.selectbox(
                            "Status",
                            options=statuses,
                            index=statuses.index(s),
                            key=f"kanban_status_{_id_str}",
                        )

                        apply_btn = st.button(
                            "Aplicar cambio",
                            key=f"kanban_apply_{_id_str}",
                            disabled=(new_status == s),
                        )

                        if apply_btn and new_status != s:
                            now = datetime.utcnow()
                            res = _update_one_by_id(
                                mongo_db["backlog_items"],
                                _id_str,
                                {"$set": {"status": new_status, "updated_at": now}},
                            )
                            if res is not None and getattr(res, "matched_count", 0) > 0:
                                st.success("‚úÖ Estado actualizado.")
                                st.rerun()
                            else:
                                st.error("‚ùå No se pudo actualizar el estado (id no encontrado).")



    with tabs[5]:
        st.subheader("üìì Diario LaTeX (V8)")
        st.caption("Captura y consulta de notas largas en LaTeX. (Sin exportaci√≥n todav√≠a)")

        notes_col = mongo_db["latex_notes"]

        st.markdown("### ‚ûï Nueva nota")
        with st.form("latex_note_create_form", clear_on_submit=False):
            c1, c2 = st.columns([2, 1])
            with c1:
                n_title = st.text_input("T√≠tulo")
                n_latex = st.text_area("Contenido LaTeX", height=260)
            with c2:
                n_date = st.date_input("Fecha", value=date.today())
                n_project = st.text_input("Proyecto (opcional)", value="")
                n_context = st.selectbox(
                "Contexto",
                ["estudio", "debug", "lectura", "idea", "reflexion"],
                index=0,
                )
                n_tags_csv = st.text_input("Tags (comma-separated)", value="")

            save_note = st.form_submit_button("Guardar nota")

        if save_note:
            if not (n_title or "").strip() or not (n_latex or "").strip():
                st.error("‚ùå Campos requeridos: T√≠tulo y Contenido LaTeX.")
            else:
                now = datetime.utcnow()
                doc = {
                "title": (n_title or "").strip(),
                "date": n_date.strftime("%Y-%m-%d"),
                "project": (n_project or "").strip() or None,
                "context": n_context,
                "latex_body": (n_latex or "").strip(),
                "tags": [t.strip() for t in (n_tags_csv or "").split(",") if t.strip()],
                "created_at": now,
                "updated_at": now,
            }
                try:
                    notes_col.insert_one(doc)
                    st.success("‚úÖ Nota guardada.")
                    st.rerun()
                except Exception as e:
                    st.error(f"‚ùå Error guardando nota: {e}")

        st.divider()
        st.markdown("### üîé Buscar notas")

        f1, f2, f3, f4 = st.columns([2, 1, 1, 1])
        with f1:
            flt_q = st.text_input("Texto (t√≠tulo o cuerpo)", value="")
        with f2:
            flt_project = st.text_input("Proyecto", value="")
        with f3:
            flt_context = st.selectbox(
            "Contexto",
            options=["(all)", "estudio", "debug", "lectura", "idea", "reflexion"],
            index=0,
        )
        with f4:
            limit = st.number_input("Limit", min_value=5, max_value=200, value=30, step=5)

        q = {}
        if flt_project.strip():
            q["project"] = {"$regex": re.escape(flt_project.strip()), "$options": "i"}
        if flt_context != "(all)":
            q["context"] = flt_context
        if flt_q.strip():
            rx = {"$regex": re.escape(flt_q.strip()), "$options": "i"}
            q["$or"] = [{"title": rx}, {"latex_body": rx}]

        try:
            notes = list(
            notes_col.find(q)
            .sort([("date", -1), ("updated_at", -1)])
            .limit(int(limit))
        )
        except Exception as e:
            st.error(f"‚ùå Error cargando notas: {e}")
            notes = []

        if not notes:
            st.info("No hay notas para este filtro.")
        else:
            for n in notes:
                nid = str(n.get("_id"))
                title = n.get("title") or "(sin t√≠tulo)"
                d = n.get("date") or ""
                proj = n.get("project") or "‚Äî"
                ctx = n.get("context") or "‚Äî"
                tags = ", ".join(n.get("tags") or [])

                with st.expander(f"{d} ‚Äî {title}", expanded=False):
                    meta1, meta2 = st.columns([2, 1])
                    with meta1:
                        st.write(f"**Proyecto:** {proj}")
                        st.write(f"**Contexto:** {ctx}")
                        if tags:
                            st.write(f"**Tags:** {tags}")
                    with meta2:
                        st.write(f"**Id:** `{nid}`")
                        st.write(f"**Updated:** {n.get('updated_at') or '‚Äî'}")

                    st.code(n.get("latex_body") or "", language="latex")
